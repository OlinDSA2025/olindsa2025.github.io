<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.17.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<script>
class AnchorNoProxy extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: "open" });
    this._$a = null;
  }
  connectedCallback() {
    const href = this.getAttribute("href") || "#";
    if (this.dataset.hasOwnProperty('canvas')) {
        const canvasURL = this.dataset.canvas;
        this.shadowRoot.innerHTML = `<style>a:hover, a:active { outline: 0; }\na { color: #5197ad; }\na:visited { color: #5197ad; }\na:hover { color: #266477; outline: 0; }</style><a href="${href}" data-canvas="${canvasURL}"><slot></slot></a>`;
    } else {
        this.shadowRoot.innerHTML = `<style>a:hover, a:active { outline: 0; }\na { color: #5197ad; }\na:visited { color: #5197ad; }\na:hover { color: #266477; outline: 0; }</style><a href="${href}"><slot></slot></a>`;
    }
    this._$a = this.shadowRoot.querySelector("a");
    this._$a.addEventListener("click", e => {
      var url = this.getAttribute('href');
      e.preventDefault();
      if (document.referrer.startsWith('https://lms.hypothes.is') && this.dataset.hasOwnProperty('canvas')) {
        // get rid of proxy if it was added
        var n = this.dataset.canvas.search('https://olin.instructure.com');
        window.open(this.dataset.canvas.substring(n), '_blank');
      } else {
        window.open(url, '_blank');
      }
    });
  }
  static get observedAttributes() { return ["href"]; }
  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      if (this._$a === null) return;
      this._$a.setAttribute("href", newValue);
    }
  }
}

customElements.define("a-no-proxy", AnchorNoProxy);

class NoProxy extends HTMLAnchorElement {
  connectedCallback() {
    this.addEventListener("click", e => {
      e.preventDefault();
      if (document.referrer.startsWith('https://lms.hypothes.is') && this.dataset.hasOwnProperty('canvas')) {
        // get rid of proxy if it was added
        var n = this.dataset.canvas.search('https://olin.instructure.com');
      	window.open(this.dataset.canvas.substring(n), '_blank');
      } else {
      	window.open(this.href, '_blank');
      }
    });
  }
}

customElements.define("no-proxy", NoProxy, { extends: "a" });

class ConfirmLink extends HTMLAnchorElement {
  connectedCallback() {
    this.addEventListener("click", e => {
      const result = confirm(`Are you sure you want to go to '${this.href}'?`);
      if (!result) e.preventDefault();
    });
  }
}

customElements.define("confirm-link", ConfirmLink, { extends: "a" });

</script>

<!-- begin _includes/seo.html --><title>Search Results - Data Structures Fall 2025 @ Olin College</title>
<meta name="description" content="">



<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Data Structures Fall 2025 @ Olin College">
<meta property="og:title" content="Search Results">
<meta property="og:url" content="/search.html">













<link rel="canonical" href="/search.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": null,
      "url": "/"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Data Structures Fall 2025 @ Olin College Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->
<script src="https://cdn.jsdelivr.net/npm/mermaid@11.9.0/dist/mermaid.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css" integrity="sha384-ZPe7yZ91iWxYumsBEOn7ieg8q/o+qh/hQpSaPow8T6BwALcXSCS6C6fSRPIAnTQs" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js" integrity="sha384-ljao5I1l+8KYFXG7LNEA7DyaFvuvSCmedUf6Y6JI7LJqiu8q5dEivP2nDdFH31V4" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
<script>
    // https://github.com/KaTeX/KaTeX/blob/main/docs/autorender.md
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
                delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false},
                {left: "\begin{equation}", right: "\end{equation}", display: true},
                {left: "\begin{align}", right: "\end{align}", display: true},
            ],
            // • rendering keys, e.g.:
            throwOnError : false
        });
    });
</script>


<script type="text/javascript">
function HideShowElement(divID) {
    const x = document.getElementById(divID);
    if (x.style.display === "none") {
        x.style.display = "block";
    } else {
        x.style.display = "none";
    }
}
</script>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="https://qeacourse.github.io/RoboNinjaWarrior/website_graphics/olinlogo.png" alt=""></a>
        
        <a class="site-title" href="/">
          Data Structures Fall 2025 @ Olin College
          
        </a>
        <ul class="visible-links"></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  

  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Search Results">
    
    
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Search Results
</h1>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
	      
                
	      	
            </nav>
          </aside>
        
        <div class="header-search">
  <form class="header-search-form" action="/search" method="get">
    <input type="text" id="search-box" name="query" />
    <input type="submit" value="search" />
  </form>
</div>

<!-- List where search results will be rendered -->
<ul id="search-results"></ul>

<script>
  // Template to generate the JSON to search
  window.store = {"sample-code-hello-world-html": {
        "title": "Hello World!",
        "author": "",
        "category": "",
        "content": "Hello world!",
        "url": "/sample_code/Hello_world.html"
      },"assignments-assignment-01-html": {
        "title": "Assignment 1: Hello Kotlin and Getting to Know You",
        "author": "",
        "category": "",
        "content": "A Note on Assignment ScopeIn general, you will be spending about 8 hours a week on homework for this class.  The first assignment, is on the lighter side, but you should still be spending at least 6 hours on it.  If you finish this assignment in less than 6 hours, please consider one of the following additional activities.  Do some problems from Advent of Code in Kotlin (note: there is a link on the useful resources page to a walkthrough of these problems).  Expand the scope of the “translating old code to Kotlin” part of the assignment.  In the “Hello Kotlin” part of the assignment, try importing a dependency and using it in your code (the Setting up Kotlin section has some information on this).Course Entry SurveyPlease fill this out.  I want to get a better sense for what you are hoping to get out of this course, what your background is, and how I can make this course work well for you.Identifying Effective Strategies for LearningWhen embarking on a course, it’s important to strategize about how to get the most out of the experience.  One might focus on how to get the best grade, but I invite you to consider the task of trying to learn as much as possible as being the primary objective (and other rewards will follow from this goal).Respond to the following prompts to get you thinking about your approach to learning in this course.  Choose a moment in your educational career (it could be an assignment or a full course) where learning went really well. What strategies did you employ that worked particularly well (e.g., working with others, trying work on your own before asking a friend, going to office hours)?  Similar to (1), which sorts of strategies have led to either less effective learning or less enjoyment of the learning experience.  Feel free to describe a few examples of what doesn’t work for you.  As this course is foundational for many aspects of computer science, the problems in this class can be easily solved with modern AI systems (e.g., ChatGPT, Gemini, etc.).  One of my foundational assumptions is the process of grappling with a problem helps you internalize the important concepts, gives you more insight into how the tools you are learning can be applied in other contexts, helps you more realistically assess your own abilities, and helps you learn to better communicate your knowledge to others.  Particular methods of using AI (e.g., prompting the AI to provide answers to questions and thoughtlessly copying the answers) are unlikely to achieve the learning goals articulated previously.  Do you agree with this framing? How are you thinking about AI tools with respect to this course?  What strategies will you use in this course to be successful?  With respect to AI, what principles or strategies will you use during this course.  What do you think of some of the proposed activities for the oral quizzes?  Are these activities ones that would give you helpful feedback as to how you are performing with respect to the course material?  Would you add or subtract any of the proposed activities?  How can the teaching team support you?Hello Kotlin!Read the section on the website about Getting Set with Kotlin.Go through the Kotlin tour (you only need to do the beginner Kotlin tour).  Make sure to attempt all the exercises in the tour.  What features do you like about Kotlin?  Are there things you were expecting to find that you haven’t?  What questions do you have?  Try using the debugger (see the Getting Set with Kotlin page) for some very basic information on the debugger.  Do you have experience using interactive debuggers like this one?  Were you able to successfully launch the debugger?  Turning in your work: You don’t have to turn in the code you write for the tour.  Please let me know that you did indeed finish the tour and turn in your answers to the questions above.Translating Your Old Code to KotlinChoose a piece of code that you’ve written in a programming language other than Kotlin.  Translate the code to run in Kotlin.  For simplicity, you may want to choose some code that will not require interacting with a lot of external libraries (although the course how-to discusses how to add dependencies to your project)The code you produce should be documented and contain at least some unit tests.  Turning in your work: Include a link to a GitHub repo containing your port of the code.  Include a writeup that describes the purpose of the code and how you found the process of translating the code to Kotlin (the good, the bad, and the ugly).",
        "url": "/assignments/assignment_01.html"
      },"assignments-assignment-02-html": {
        "title": "Assignment 2: Linked Data Structures",
        "author": "",
        "category": "",
        "content": "OverviewIn this assignment you will be implementing a doubly linked list in Kotlin.  You’ll then utilize your linked list class to create both a queue and a stack.  Once you’ve done that, you can use your newly minted data structures to solve some code-interview style problems.Part 1: Doubly Linked ListImplement a doubly linked list in Kotlin.  Your class should work with any data type (use Kotlin’s generics).  Your linked list should implement the following interface (we use T to refer to the data type stored in the underlying linked list).interface LinkedList&lt;T&gt; {    /**     * Adds the element [data] to the front of the linked list.     */    fun pushFront(data: T)    /**     * Adds the element [data] to the back of the linked list.     */    fun pushBack(data: T)    /**     * Removes an element from the front of the list. If the list is empty, it is unchanged.     * @return the value at the front of the list or nil if none exists     */    fun popFront(): T?    /**     * Removes an element from the back of the list. If the list is empty, it is unchanged.     * @return the value at the back of the list or nil if none exists     */    fun popBack(): T?    /**     * @return the value at the front of the list or nil if none exists     */    fun peekFront(): T?    /**     * @return the value at the back of the list or nil if none exists     */    fun peekBack(): T?    /**     * @return true if the list is empty and false otherwise     */    fun isEmpty(): Boolean}Make sure to include unit tests for each of these operations.  It’s okay if a single unit test simultaneously tests multiple of these functions.Stack and Queue Abstract Data TypesThe Stack abstract data type (ADT) can be represented by the following Kotlin interface.interface Stack&lt;T&gt; {    /**     * Add [data] to the top of the stack     */    fun push(data: T)    /**     * Remove the element at the top of the stack.  If the stack is empty, it remains unchanged.     * @return the value at the top of the stack or nil if none exists     */    fun pop(): T?    /**     * @return the value on the top of the stack or nil if none exists     */    fun peek(): T?    /**     * @return true if the stack is empty and false otherwise     */    fun isEmpty(): Boolean}The Queue abstract data type is:interface Queue&lt;T&gt; {    /**     * Add [data] to the end of the queue.     */    fun enqueue(data: T)    /**     * Remove the element at the front of the queue.  If the queue is empty, it remains unchanged.     * @return the value at the front of the queue or nil if none exists     */    fun dequeue(): T?    /**     * @return the value at the front of the queue or nil if none exists     */    fun peek(): T?    /**     * @return true if the queue is empty and false otherwise     */    fun isEmpty(): Boolean}Stack and Queue Implementations  Exercise 1: Using your linked list class as a data structure, create a class that implements the stack abstract data type.  Make sure to include unit tests to ensure your code is correct.  Since you are reusing your linked list class, you should not be implementing the stack operations from scratch (your functions should primarily be one-liners).  Exercise 2: Using your linked list class as a data structure, create a class that implements the queue abstract data type.  Make sure to include unit tests to ensure your code is correct.  Since you are reusing your linked list class, you should not be implementing the queue operations from scratch (your functions should primarily be one-liners).Practice Problems with Stacks and QueuesThese next problems are similar to the types of problems you might encounter in a technical interview.  You should work out a strategy for implementing all fo them, but you only need to implement one in Kotlin.  Exercise 3: How would you reverse the elements in a stack (i.e., put the elements at the top of the stack on the bottom and vice versa)?  You can use as many additional stacks and queues as temporary storage in your approach.  Exercise 4: Come up with a strategy to solve the valid parentheses problem.  Exercise 5: Solve the copy stack problem (source: University of Washington CSE122)  Given a stack return a copy of the original stack (i.e., a new stack with the same values as the original, stored in the same order as theoriginal). Your method should create the new stack and fill it up with the same values that are stored in the original stack.  You may use one queue as auxiliary storage.  Optional problems you might check out (totally optional… let’s find more together)      Splice stack    https://leetcode.com/tag/queue/    https://leetcode.com/tag/stack/    https://leetcode.com/problems/simplify-path/    Some practice problems recommended by CA Eddy Pan! (click on Stack after following the link)  ",
        "url": "/assignments/assignment_02.html"
      },"assignments-assignment-03-html": {
        "title": "Assignment 3: Graph Searching and Shortest Paths",
        "author": "",
        "category": "",
        "content": "Getting StartedI am providing some starter code for this assignment.  The starter code (shown below) can be copy / pasted into your project.You may also want to check out the tips and tricks section.Representing GraphsCreate a Kotlin class to represent a directed, weighted graph.  Your graph should implement the Graph&lt;VertexType&gt; interface shown below./** * ``Graph`` represents a directed graph * @param VertexType the type that represents a vertex in the graph */interface Graph&lt;VertexType&gt; {    /**     * @return the vertices in the graph     */    fun getVertices(): Set&lt;VertexType&gt;    /**     * Add an edge between [from] and [to] with edge weight [cost]     */    fun addEdge(from: VertexType, to: VertexType, cost: Double)    /**     * Get all the edges that begin at [from]     * @return a map where each key represents a vertex connected to [from] and the value represents the edge weight.     */    fun getEdges(from: VertexType): Map&lt;VertexType, Double&gt;    /**     * Remove all edges and vertices from the graph     */    fun clear()}  You should be able to retrieve a collection of vertices in the graph (e.g., you might maintain a MutableList or a MutableSet that contains all of your vertices.). In the interface above this is the function getVertices.  Given a vertex, $v$, you should be able to retrieve a collection of vertices that are neighbors of $v$ (that is any vertex $m$ such that there exists an edge $v \\rightarrow m$). In the interface above this is the function getEdges.Creating a Priority QueueCreate a data structure called PriorityQueue that implements the following interface./** * ``MinPriorityQueue`` maintains a priority queue where the lower *  the priority value, the sooner the element will be removed from *  the queue. *  @param T the representation of the items in the queue */interface MinPriorityQueue&lt;T&gt; {    /**     * @return true if the queue is empty, false otherwise     */    fun isEmpty(): Boolean    /**     * Add [elem] with at level [priority]     */    fun addWithPriority(elem: T, priority: Double)    /**     * Get the next (highest priority) element and remove this element from the queue.     * @return the next element in terms of priority.  If empty, return null.     */    fun next(): T?    /**     * Adjust the priority of the given element     * @param elem whose priority should change     * @param newPriority the priority to use for the element     *   the lower the priority the earlier the element int     *   the order.     */    fun adjustPriority(elem: T, newPriority: Double)}In order to implement your priority queue, you’ll want to create a MinHeap.  For your MinHeap you can either build it from scratch (e.g., using this Wikipedia page as a guide) or you can build off (or probably just use) the reference implementation here.  The priority queue will be a pretty thin wrapper on top of this heap.  If you implement the MinHeap yourself, you can earn 2 points of extra credit on the assignment (equivalent to a 20% boost in your grade).SearchingImplement Dijkstra’s algorithm to search through a graph for the shortest path.  Your algorithm should return the shortest path (not just the cost) between a given start node and a given destination node.  If no path exists between the two nodes, return null.Solving Problems with DijkstraDijkstra can be used to solve a bunch of problems.  Here are some you might want to try for practice.  Choose at least one of these options and implement it in Kotlin using the code you wrote earlier in the assignment.  Project Euler Problem 81 (also look at 82 and 83 for harder variants)  Implement a Maze Solver  Create a graph that represents the cost (however you want to define it) to travel between particular various cities (you choose which ones).  Compute some shortest paths on this graph using your Dijkstra implementation.  If you want to define a map on a different level of granularity (e.g., city streets) that is cool too!Turning in your CodeEither submit your code as a GitHub link or upload the code directly to Canvas.AssessmentSee the rubric on Canvas.Tips and TricksSuppose you have computed a path to the vertex target and along the way populated a map called prev: MutableMap&lt;VertexType, VertexType&gt; where prev[v] indicates the previous element along the path.  In order to reconstruct the full path from the start to target, you may find the generateSequence function useful. In the code below, I’ve used the one that lets you specify a seed to start the sequence.generateSequence(seed=target) {    curr -&gt; prev[curr]}.toList().asReversed()",
        "url": "/assignments/assignment_03.html"
      },"assignments-assignment-04-html": {
        "title": "Assignment 4: Sorting Algorithms",
        "author": "",
        "category": "",
        "content": "OverviewThis assignment is about implementing, benchmarking, and solving problems with sorting algorithms.Sorting Algorithm Implementation and Complexity AnalysisImplement at least four sorting algorithms.  For each sorting algorithm you implement, provide an analysis of its computational complexity.  At least one of your algorithms should be $\\Theta(n \\log n)$.Here are some possible algorithms to implement.  Heap sort  Radix sort  Insertion sort  Selection sort  Merge sort  Quick sortSorting Algorithm BenchmarkingTest the performance (meaning how long it takes for the code to run) of your sorting algorithms on sorting different sized lists of numbers.  Create some representation (e.g., a table or a plot) of the runtimes of the algorithms as a function of list size.  In a writeup (I would suggest a markdown file), discuss how you tested your algorithms (e.g., how you generated the lists to be sorted, how many times you performed each experiment).  Draw some conclusions based on your experiment (e.g., which algorithm seems faster and in which cases).Tips 1: You should try running your algorithms on lists of vastly different sizes (think different orders of magnitude).  For example, try a lists of size $10$, $100$, $1,000$, $1,000,000$.Tip 2: To generate your lists, you should consider using random numbers.  This code generated a list of desiredSize where each number is from 0 to 999.  Please adjust as you see fit.// somewhere above you need: import kotlin.random.Randomval x = (1 until desiredSize).map { Random.nextInt(1000) }Tip 3: to time your code, you can use the measureTime Kotlin function.// somewhere above you need: import kotlin.time.measureTimeval runTime = measureTime {    // put in call to your sorting algorithm here}println(\"my algorithm took $runTime to run\")Tip 4: it helps to automate as much of this as possible.  Here is some code that runs built-in sorting algorithm on a few different list sizes.// somewhere above you need: import kotlin.time.measureTime// somewhere above you need: import kotlin.time.DurationUnit// somewhere above you need: import kotlin.random.Randomval runTimes = mutableListOf&lt;Double&gt;()for (size in listOf(10, 100, 1000, 10000, 100000)) {    val x = (1 until size).map { Random.nextInt(100000) }    val runTime = measureTime {        x.sorted()    }    runTimes.add(runTime.toDouble(DurationUnit.SECONDS))}println(\"Runtimes are $runTimes\")New Frontiers in Sorting?  This is now extra creditDo some research to determine what new problems exist in terms of sorting.  In your writeup, discuss at least one variant of sorting that has active research.  Make sure you explain what solving this problem entails.  Read one research paper that is related to this sorting problem and summarize its contributions (you may not be able to understand the paper at full detail, but hopefully you can get the gist).Practice with the master theorem  Time box this to an hour or soDo this worksheet from MIT 6.046 by applying the master theorem.  There are solutions available here.  Note that the master theorem doesn’t apply to all of these problems, so if it doesn’t fit the patterns, you can just say it doesn’t apply (no need to try to work out the solution).  Please ignore the part on the worksheet where it says you can go through the whole worksheet in 10 minutes!! Not the case!Turning in your workSubmit a link to a repository that has your code and writeup.  Make sure to add me paulruvolo as a collaborator if the repo is private.AssessmentSee the rubric on Canvas.",
        "url": "/assignments/assignment_04.html"
      },"assignments-assignment-05-html": {
        "title": "Assignment 5: Divide and Conquer and Dynamic Programming",
        "author": "",
        "category": "",
        "content": "OverviewThis assignment is about solving problems using by breaking the problem down into smaller problems and then reassembling the solutions to the smaller problems into the solution to the original problem.  We will use a combination of divide and conquer algorithms and dynamic programming to solve these problems.Part 1: Creating a matrix classFor the first part of the assignment, we will be learning about a divide-and-conquer algorithm for matrix multiplication called Strassen’s Algorithm.To get started, create Kotlin class capable of storing square matrices.  I won’t be overly prescriptive about how you write your class, but you should support basic operations like creating a matrix of size $n$, setting / getting values at specified row and column indices, dividing the matrix into four $n/2 \\times n/2$ matrices (this is needed for Strassen).  Don’t worry about matrix multiplication yet, that’s coming!  Pro tips:      You can make your matrix class especially nice by overloading operators (e.g., +, *). This will let you do things like A * B (assuming you have two Matrix objects A and B).  If you don’t use overloading, you might write A.multiply(B).  For more information, check out the Kotlin documentation on operator overloading.    To store the underlying data for your matrix, I have two recommendations.  First, you could store your data using an array of arrays structure (e.g., val data: Array&lt;DoubleArray&gt; = Array(n) { DoubleArray(n) }).  Second, you could store your data as a linear array (e.g., DoubleArray(n*n)) where the first row is laid out as the first n elements of the array, the next row is the following n elements of the array, etc.  This type of storage is called row major ordering.  Part 2: Strassen’s Algorithm for Matrix MultiplicationAdd the functions multiply and strassenMultiply to your matrix class. These functions should do the following (note: here I’m using Matrix as a stand-in for whatever you call your class from part 1 of the assignment)class Matrix {    // ... (other stuff omitted)        /**     * Multiply [this] matrix by [other].     * You can implement this either using block-based matrix multiplication or     * traditional matrix multiplication (the kind you learn about in math     * classes!)     * @return [this]*[other] if the dimensions are compatible and null otherwise     */    fun multiply(other: Matrix):Matrix? {        // your implementation here    }    /**     * Multiply [this] matrix by [other].     * Your code should use Strassen's algorithm     * @return [this]*[other] if the dimensions are compatible and null otherwise     */    fun strassenMultiply(other: Matrix):Matrix? {        // your implementation here    }}  Warning: there are some writeups of Strassen’s algorithm that have errors in them.  Last time I ran this course, we found at least two different sets of class notes that had errors.  If you go from description on the Wikipedia page, then you should be good.Write some unit tests to show your code is correct.  Time Strassen and regular matrix multiplication on various size problems.  You may find the Strassen does not reliably outperform conventional matrix multiplication.  A hybrid approach may work better where you use conventional matrix multiplication for smaller matrices and Strassen for larger matrices.  What appears to be the optimal size matrix where you should switch between Strassen and conventional multiplication?  What to turn in for this part:      Your Matrix class with all operations implemented, unit tested, and documented.    Benchmarks (meaning the runtime) of the two algorithms (as described above).    Your analysis of the performance of a hybrid algorithm that uses Strassen for large matrices and switches to conventional matrix multiplication for smaller matrices.  Part 3: Dynamic Programming for Aligning Protein SequencesWatch the following video on the sequence alignment problem.  Hopefully, it will give some good motivation behind what the problem is and why it’s important.Implement either the Needleman-Wunsch Algorithm or the Smith-Waterman Algorithm for sequence alignment.  Needleman-Wunsch is used for aligning two DNA sequences globally (an alignment between the entirety of each sequence is returned).  Smith-Waterman finds a local sequence alignment (it finds a part from each of the sequences that align well to each other).You may find this resource useful for testing your code and understanding the algorithms.  The Wikipedia pages are also a nice source for unit tests.Your code should find both the best alignment and use backtracing to display the alignment itself.  You should use dynamic programming when implementing your algorithm.Run your code on the DNA sequence in this Kotlin file.  This file has three variables.  genomeSnippet is a snippet of a Salmonella genome.  targetGenome is a long section of the Salmonella DNA (genomeSnippet is contained completely within this string)  testAgainst is a different segment from the Salmonella genome (not exactly the same as genomeSnippet) that you can use for matching.If you are doing Smith-waterman you would match testAgainst and targetGenome.  If all goes well, you should find that testAgainst matches well to the portion of targetGenome that contains genomeSnippet.If you are doing Needleman-Wunch, you can match genomeSnippet against testAgainst.  You should find that your algorithm is able to closely align the two sequences.Here is an alignment between part of a Salmonella genome and another part of the same genome.I got this alignment by using a tool call Nucleotide blast on genomeSnippet and selecting optimize for somewhat similar sequences.  The two parts of the alignment correspond to proteins that help the Salmonella cell infect the cells of the body.  One protein helps with the initial entry into the cell whereas the other protein helps with manipulating the functions of the cell the bacteria has entered the cell.  What to turn in for this part:      Your implementation of one of the two algorithms for sequence alignment.  Functions should be unit tested and commented.    The result of running your code on the provided DNA sequences.  This should consist of the best matching sequence to the query.  Turning in your workSubmit a link to a repository that has your code and writeup.  Make sure to add paulruvolo as a collaborator if the repo is private.  See the what to turn in for this part sections above for guidance on completing each part.AssessmentSee the rubric on Canvas.",
        "url": "/assignments/assignment_05.html"
      },"assignments-assignment-06-html": {
        "title": "Assignment 6: Individual Deep Dive",
        "author": "",
        "category": "",
        "content": "OverviewThis assignment will consist of an individual deep dive on an application or algorithm related to the themes of this class.Areas of InvestigationFor your project, you should choose one or more of the following areas of investigation.  In terms of scoping, this should equate to about 8 hours of work (not including the time to come up with the project topic and write the proposal).  Learn about and (likely) implement a new algorithm.  You could choose a true classic: All Pairs Shortest Path, Ford-Fulkerson for maximum network flow, Page Rank, Fast-Fourier Transform, Viterbi Algorithm for Hidden Markov Models, K-Means clustering, Policy Iteration for optimal planning, Simplex Method for linear programming, etc.  You could choose an algorithm from a research paper of interest.  Apply an algorithm we already learned about to an interesting problem.  Take one of the algorithms you’ve already implemented and try it on a non-trivial problem.  Take one of the assignments further.  You might try various optimizations to your code to improve runtime (make sure to pair this with benchmarks that show the change in performance).  You might want to implement additional features or variants of your algorithm (e.g., additional sorting algorithms).  Do some research to determine how a particular algorithm is being applied currently or has been applied in the past.DeliverablesProject Proposal (2 points)Turn in a project proposal that lays out your plan for the project.  Clearly specify what your project will entail, what deliverables you will create, and how much time you think each part will take.  With your proposal, include a rubric for grading your project (what does “A”-level performance look like, “B”-level, etc.).Other Deliverables (8 points)You are required to include a brief summary of what you did for the project and a summary of all other deliverables.   Some other deliverables you might have (this is a list of options… you will not have all of these):  Kotlin code (so you will want to send a link to a repository).  A summary of how an algorithm a particular algorithm you studied works  A report on former and current applications of your algorithm.  A report on the changes in performance that resulted in optimizing your code.  A report that summarizes an application or experiment you did.Advice for Choosing a ProjectThink back to why you took this class.  Are there learning goals that you would like to bolster now that we are roughly halfway through the semester?  Is there a new area you learned about that you are excited about that you want to investigate in greater detail?  What sort of work do you want your project experience to consist of (e.g., writing code, reading papers, recording a whiteboard walkthrough of an algorithm)?Some Sample Projects from Last Time  learn about the KMP algorithm and use it to efficiently implement a find / replace feature.  Implement and benchmark the Fast Fourier Transform (FFT)  Implement Floyd Warshall (x2)  Karatsuba algorithm for fast integer multiplication  Quantum Fourier Transform (QFT) via the Deutsch-Josza algorithm  Ford-Fulkerson Algorithm (x2)  1D and 2D Fast Fourier Transform (FFT)  Learn about, implement, and test the Q-learning algorithm for reinforcement learning  PageRank (x2)  K-Means clustering (x2)  Policy Gradient algorithm for reinforcement learning  Approximation algorithms for the traveling salesman problem  Benchmark and implementation of a hybrid sorting algorithm",
        "url": "/assignments/assignment_06.html"
      },"in-class-day01-html": {
        "title": "Day 1: Course Intro and Welcome to DSA",
        "author": "",
        "category": "",
        "content": "Let’s Settle In and Meet Each Other  Time 2:50-2:55pmCan we do a quick round of intros?  How about name, year, school, and where you’re from?Course Structure and Major Topics  Time: 2:55-3:05pmThe goal of this course is for you to learn how to frame problems using the language of computation and select appropriate data structures and algorithms to solve them.  We’ll get more into what we mean by framing problems later (there is an example later today), but for now I want to focus on the sorts of problems we will be tackling and the algorithmic strategies we will be using to solve them.Data Structures  Before talking about data structures, let’s talk about data.  What sorts data do we need to consider when designing computer algorithms?  Data structures as supports for algorithms.  Ultimately, data structures are useful to solve certain problems.  There are many properties we might care about when we select a data structure.  Can we brainstorm some of these properties as a class?  We’ll be learning about basic linked data structures (linked lists, stacks, queues), data structures to represent graphs and trees (e.g., binary search trees or heaps), and data structures that use hashing to index and retrieve data.Algorithmic Design PatternsWhile each algorithm must be tuned to the particular problem being solved, there are general algorithm types that we will encounter (e.g., some algorithms work by breaking a larger problem into smaller instances, some use a greedy approach, others are based on backtracking or graph search).Analyzing AlgorithmsWe want to develop ways to talk about the computational (how long it takes to compute a solution) and spatial (how much space is needed in a computer’s memory to compute a solution) complexity of algorithms.  We can look at these factors with both theoretical (e.g., doing some analysis to understand how long an algorithm runs based on the problem size) and empirical tools (e.g., measuring the actual time it takes an algorithm to run on a computer).Specific AlgorithmsOf course, we will learn about specific algorithms.  We’ll see algorithms from graph theory, string matching, bioinformatics, sorting, matrix multiplication, backtracking, and artificial intelligence.Applications of AlgorithmsWe’ll see some instances of how particular algorithms can be applied to solve problems in specific fields (e.g., text retrieval and indexing, bioinformatics).Algorithmic Deep DiveYou’ll be able to customize the course by taking a deep dive into a new algorithm or algorithms topic that we did not cover in the class.Implementation and TestingIn order to solidify your understanding of the material and improve your ability as a developer, we will be implementing many of our algorithms and data structures.  We’ll focus on creating unit tests as a way to create more maintainable and correct code.Algorithms in the World  Time: 3:05pm-3:30pmChoose a category of algorithms from the list below (or make up your own). You are not supposed to know all (or any) of these already!  I encourage you to choose ones you don’t know about and do some research. Alternatively, warm up with one you are familiar with and then choose one less so.  For each category you choose to look into:  What problem does the algorithm solve?  List the metrics that an algorithm designer might care about when creating an algorithm of this type.  List at least two examples of how algorithms of this type are used in the world (applications).Some examples of algorithms are listed below.  Data Compression (lossless or lossy)  Collaborative filtering (e.g., as used in recommender systems)  Encryption  Routing (e.g., of Internet traffic or for navigation instructions)  Task Assignment  Sorting  Matrix Multiplication  Fourier Analysis  Semantic search  (come up with your own…. there are so many!)  Bonus question: list all the algorithms that you and your team have interacted with since you got up this morning.Discussion of Learning Strategies and Oral Quizzes  Time: 3:30pm-3:50pmNext, I want to discuss two interrelated issues.  The first is how you can work in a way that best supports your learning this semester.  The second is how I can provide an assessment structure that provides you with useful feedback.While there are many aspects of assessment in this course, for now I want to focus on something new I’m trying this semester.  Twice this semester, I will meet with each of you for an oral quiz (each quiz is worth 10% of your grade).  My hope is that this structure will give you a better measurement of your progress over the semester.  Partially, my decision is based on mitigating what I feel are ways in which AI-based coding assistants might hinder learning in this course (e.g., if they are used as answer generators rather than coaches).  I’m not ready to nail down the full design of these quizzes, but here are some preliminary thoughts.            Activity      What’s Being Assessed              You are given a problem to solve. As you work towards a solution, you show / discuss your thought process.      Your ability to select appropriate data structures and algorithms to solve a novel problem.              You are asked to explain a section of code from one of your submitted assignments.      Your ability to internalize, and be able to verbalize to others, the coding choices you made.              You are asked to give a whiteboard talk explaining one of the class concepts.      Your fluency with the concepts in the course, your ability to distill down the important bits, and your ability to communicate clearly about course concepts.              You are given an implementation of a particular algorithm, and you must work through whether the code is correct. If it is not correct, you may suggest corrections.      Your ability to comprehend code that you didn’t write and assess its correctness.      With some folks around you, please discuss the following.  What are some learning strategies that have worked particularly well for you in the past?  Do you think they will work well in this course?  Will you use AI-based coding assistants in this course?  How will you use them to ensure you are getting the knowledge you’d like from the course?  In reaction to the table above, what other activities would be useful to include in an oral quiz and what skill would they be assessing?Having Some Fun With Algorithms  3:50pm - 4:20pmQuantifying RuntimeIn this class we’re going to be reasoning about the efficiency of our algorithms with respect to the size of the problem they are solving.  For instance, if we feed $n$ numbers into an algorithm, how long does it take the algorithm to compute a solution?  Depending on how the algorithm works, this might take $n^2$ (e.g., if we had to check all pairs of inputs against each other) or $n$ (e.g., if we only had to scan the inputs once).  In the problems below, you’ll want to come up with a procedure for solving the problem and also determine how many steps the algorithm would take to compute an answer as a function of $n$.  For the purposes of these exercises, the following operations take 1 step.  Accessing an element in a list (e.g., $a_2$)  Comparing two numbers to each other (e.g., $a_3 &gt; a_8$)Work through the peak-finding problem with a group of people sitting near you.  If you finish the first problem, you can either look into 2D peak-finding, or check out the first assignment.  The goal here is not for you to be able to jump right to the answer, but instead, to break down the problem and discuss it with those around you.Peak Finding  Credit to MIT Open Courseware 6.006 for this problemSuppose we have a list of numbers represented as a sequence $a_1, \\ldots, a_n$ with $n \\geq 2$.  For any element that isn’t either the first or the last element of this sequence, we say that element $i$ is a peak if and only if $a_i \\geq  a_{i-1}~\\text{and}~a_i \\geq a_{i+1}$.  For the elements at the ends of the sequence, we say that $a_1$ is a peak if and only $a_1 \\geq a_2$ and $a_n$ is a peak if and only if $a_n \\geq a_{n-1}$.With some folks around, you answer the following questions:Unpack the notation.  Write out a simple test case and label the values with the appropriate notation (e.g., write a list of numbers and draw an arrow to the first that says $a_1$, to the second that says $a_2$, etc.Get a feel for the condition written above.  Draw a few test cases.  When does a peak exist?  When does it not?Come up with a very simple algorithm to return the position, $i$, of a peak in a list of numbers (provided one exists).  As a function of $n$, how many elements do you have to check to determine if you have a peak?See if you can create an algorithm to find a peak faster than your first algorithm (faster in this case means it has a slower growing runtime as a function of $n$).  What techniques might be able to speed things up?  Make an argument that your algorithm is correct and see if you can start to understand how you might prove this more formally.Show / Hide Hint 1You should think about breaking the problem down into simpler instances.Show / Hide Hint 2Think recursively.  Here is a convenient link to the material from SoftDes on the matter (or call me over and we can do a quick refresher)!  What test can you perform that would allow you to recurse on a sequence half as large as the one you started with?If we changed the condition of a peak to the definition below, would your algorithm in question 3 still work?  Definition 2: For any element that isn’t either the first or the last element of this sequence, we say that element $i$ is a peak if and only if $a_i &gt; a_{i-1}~\\text{and}~a_i &gt; a_{i+1}$.  For the elements at the ends of the sequence, we say that $a_1$ is a peak if and only $a_1 &gt; a_2$ and $a_n$ is a peak if and only if $a_n &lt; a_{n-1}$.2D Peak Finding  Note: this is mostly just here for reference for the folks who are curious.  I do not expect you to be able to get to this during class time.Can we generalize the ideas from the peak-finding algorithm to 2 dimensions (i.e, a matrix)?  Yes!  Here are some slides that talk about the 1-D and 2-D peak-finding algorithms (my suggestion is to go up to slide 17)Orientation to Assignment 1  4:20pm - 4:25pmLet me show you the first assignment (due next Thursday).Turning in your work  4:25pm - 4:30pmPlease fill out the Canvas survey to complete your assignment for today.  These surveys are not intended to be heavy -weight.",
        "url": "/in_class/day01.html"
      },"in-class-day02-html": {
        "title": "Day 2: Greedy Algorithms Teaser, Order of Growth, and Some Kotlin",
        "author": "",
        "category": "",
        "content": "Announcements and Reminders  If you haven’t yet, please fill out the office hours when2meets (see Canvas).  Consider joining the Slack.Algorithm Design Patterns Whirlwind TourWe’re going to take a few classes to get a feel for the various algorithmic design patterns we will meet this semester.  During class 1, we met the design pattern divide and conquer.  Today, we’ll be learning about greedy algorithms.Wikipedia has a concise definition of a greedy algorithm.  A greedy algorithm is any algorithm that follows the problem-solving heuristic of making the locally optimal choice at each stage.The question becomes, does the greedy strategy lead to an optimal solution to the problem?  In some cases it may lead to such a solution, and in other cases it may not.  Sample Problem Seeing where a greedy approach fails  To make sure we understand which problems can be solved with a greedy algorithm, it may be more intuitive to think about some cases that a greedy algorithm cannot solve. Let’s work through an example of this to all get on the same page.  Knapsack Problem: Given $N$ items where the $i$th item weights $w_i$ pounds, determine an assignment of items to two knapsacks such that the combined weight of the items in each knapsack is the same.  Example: There are five items with weights $6, 5, 9, 1, 1$.  Solution: Knapsack 1: ${5, 6}$, Knapsack 2: ${1, 1, 9}$.  What’s the greedy approach?  Let’s start with the knapsacks empty and choose the combination of knapsack and item that causes the total weight in each knapsack to stay as close as possible.  Let’s track how the knapsacks $K_1$, $K_2$, and the remaining items, $R$, would evolve over time if we applied this procedure.      $K_1 = [ 1 ], K_2 = [ ], R = [6, 5, 9, 1]$    $K_1 = [ 1 ], K_2 = [ 1 ], R = [6, 5, 9 ]$    $K_1 = [ 1, 5 ], K_2 = [ 1 ], R = [ 6, 9 ]$    $K_1 = [ 1, 5 ], K_2 = [ 1, 6 ], R = [ 9 ]$    $K_1 = [ 1, 5, 9 ], K_2 = [ 1, 6 ]$    This approach has clearly failed since the weights in $K_1$ total 15 and the weights in $K_2$ total 7.Now, let’s work through the following exercise as a group.  Exercise 1      Suppose you have a budget of $N$ dollars to purchase flour and that flour can be purchased on day $i$ for $x_i$ dollars per pound.  Determine the maximum amount of flour you can purchase with your budget.  Is your algorithm a greedy algorithm? (you can assume that buying a fraction of a pound is allowed).  How would you modify your algorithm if you were limited to purchasing $M$ pounds of flour each day?  Is the new algorithm greedy?    Determine a greedy algorithm for making change for $N$ cents using quarters, dimes, nickels, and pennies.  Does your greedy algorithm use the fewest coins possible (make an intuitive argument, no proof necessary)?    If the US began minting a 20-cent coin, would a greedy algorithm still solve the optimal change-making problem? (Wikipedia has some useful information on the change-making problem if you want to learn more)  Optimal Roadtripping  Exercise 2 You are planning a road trip of $N$ miles.  Your electric car has a range of $M$ miles.  There are charging stations located at mile $a_1, a_2, a_3, \\ldots, a_k$ (as measured from the start of the route).  Determine a procedure to figure out the minimum number of recharges you have to make in order to complete the road trip.  Show / Hide Hint 1  Start by thinking about the first decision you have to make (where to make your first recharging stop).  Is there a best first place to stop?  Show / Hide Hint 2  Assuming that you recharge completely each time you choose to stop, does it ever make sense to stop at an earlier charging station than you could have reached?O() and FriendsNext, we are going to return to what we did in the first class where we calculated the runtime of an algorithm as a function of the input size $n$.  Let’s say we compute the runtime of an algorithm 1 to be $2 n^2 + 5n + 200$ and the runtime of algorithm 2 to be $3 n^2 + 2 n$.  Is one necessarily faster than the other?  We can graph the two runtimes and see.Something interesting happens around $n=16$ (the lines cross).  However, if we let the input size get really large and plot the ratios of the two runtimes, we can see that algorithm 2 takes 50% longer to run than algorithm 1.The idea behind order of growth, is to find a way to draw meaningful distinctions between how fast functions increase.  Where meaningful in this case is based on how the functions behave when the input, $n$, gets very large and where we ignore constant factor differences in the functions (e.g., if a function is twice another, it is pretty much the same for our purposes).We say that $f(x) = O(g(x))$ if there exists a positive real number $M$ and a real number $x_0$ such that, $|f(x)| \\leq M g(x)~\\text{for all}~x\\geq x_0$.$f(x) = \\Omega(g(x))$ if there exists a positive real number $M$ and a real number $x_0$ such that, $|f(x)|\\geq M g(x)~\\text{for all}~x \\geq x_0$We say that $f(x) = \\Theta(g(x))$ if $f(x) = O(g(x))$ and $f(x) = \\Omega(g(x))$.Here is a handy figure from “Introduction to Algorithms” by Cormen, Leiserson, Rivest, and Stein.With your group, explain how the formal definitions (given earlier) relate to these pictures.  Exercise 3      Show that $10000 n = O(n^2)$ (let’s do this one together).    Show that $n^2 \\neq O(n)$.Show / Hide Hint      Write out the condition for $O()$ and show that it cannot be satisfied.        Show that $\\frac{3^n}{10000} = \\Omega(2^n)$Show / Hide Hint      Follow the blueprint by writing out the condition for $\\Omega$.  You don't have to necessarily find $x_0$, but convince yourself that one exists.        Argue (up to you how formal to make your argument) that any polynomial is $O(2^n)$    Exercise 4 This problem is from former Olin Professor Allen Downey’s Think Python second edition.   In this context, order of growth can be understood to mean $\\Theta$.  I made one modification to part 3 of the exercise.      What is the order of growth of $n^3 + n^2$? What about $1000000 n^3 + n^2$? What about $n^3 + 1000000 n^2$?    What is the order of growth of $(n^2 + n)(n + 1)$?    If $f$ is in $O(g)$ and $g$ is a continuously increasing functions that grows infinitely large as $n \\rightarrow \\infty$, what can we say about $af+b$, where $a$ and $b$ are constants?    If $f_1$ and $f_2$ are in $O(g)$, what can we say about $f_1 + f_2$?Show / Hide Hint      What do we know about based on the fact that $f_1$ and $f_2$ are in $O(g)$, can we write down a useful condition?        If $f_1$ is in $O(g)$ and $f_2$ is in $O(h)$, what can we say about $f_1 + f_2$?Show / Hide Hint      You can use max(g, h) to refer to the bigger of the functions.        If $f_1$ is in $O(g)$ and $f_2$ is $O(h)$, what can we say about $f_1 \\times f_2$?  Peak finding in KotlinLet’s create an implementation of the peak-finding algorithm we determined in class last time.  If you are not here for the live demonstration (or if we somehow run out of time), you can find the solution in the class sample solutions repo under Class01.",
        "url": "/in_class/day02.html"
      },"in-class-day03-html": {
        "title": "Day 3: Arrays, Linked Lists, and Intro to Abstract Datatypes",
        "author": "",
        "category": "",
        "content": "Homework DebriefHow did the assignment go?  Do a quick check-in with those around you and see if you can surface 1-2 questions that are still unresolved for you.Meeting Our First Data StructuresToday we’re going to meet our first data structures of the semester: the array and the linked list.  We’ll talk about tradeoffs in terms of runtime of various operations on these data structures.  We’ll also introduce the concept of abstract data types (ADTs) as a tool for separating the implementation of a data structure from the operations it supports.ArraysAs we mentioned on day one, data structures represent different approaches to organizing data in some digital storage system.  In this course, we’re going to learn about a bunch of different data structures (e.g., linked lists, arrays, binary trees, graphs, etc.).  To help us wrap our minds around the big ideas of data structures, let’s consider a very useful data structure: an array.Depending on your programming background, perhaps you haven’t encountered an array yet.  An array is an ordered collection of values (usually of a particular type).  Arrays are typically implemented in a computer using a contiguous block of memory (e.g., stored in the computer’s RAM).When we create an array, we have to specify the capacity that we’d like our array to have (that is the size that we’d like to reserve for our array in the computer’s memory).  Upon requesting an array of a particular size, we will be allocated a contiguous region in the computer’s memory to store our values.  We can assume that requesting and being assigned a region in memory is relatively efficient (think of this as taking a constant number of operations).  Further, we can assume that we can efficiently write and read values from an array (think of these as taking a constant number of operations).Time Complexity of Various Array OperationsAs stated above, for these operations we can assume that requesting new memory, reading a single value, and writing a single value for our array takes a constant number of operations.  Exercise 1: Suppose you have an array with $M$ elements and there is space for $C$ elements in the block of memory allocated to your array (with $M &lt; C$).  Assume that the $M$ elements are stored such that they occupy the first $M$ slots of memory allocated to the array.  How many steps would it take to add a new element to the end of your array? Going back to our discussion of order-of-growth, what is the running time of this operation in terms of $\\Theta$?  Exercise 2: Now, suppose you’d like to add an element to the beginning of your array.  If there are currently $M$ elements in your array, how many operations would it take to add an element to the beginning of the array?  What is $\\Theta$ for this operation?  Exercise 3: Now, suppose you want to add an element ot the end of your array but the number of elements stored in the array is equal to the current capacity $M = C$.  How many operations would it take to perform the following steps: request a size $M+1$ block of memory, copy the first $M$ elements to the new memory block, and then add the new element to the array?  Suppose you start $M = C = 1$ (an empty array with no capacity).  How many operations would it take to add $N$ elements to the end of this array if you added them one-by-one?  Determine $\\Theta$ of the time complexity of adding these $N$ elements.  Show / Hide Hint  If you add up the time it takes to add each element, what sort of series do you get?  How do you calculate the sum of this type of series?  Exercise 4: Similar to the previous problem, suppose you want to add $N$ elements to the end of an array in a one-by-one fashion.  Let’s see if we can do better than we did in problem 3.  Instead of adding 1 unit of capacity every time we run out of space in our array, we’re going to multiply our capacity by a factor of 2 (e.g., starting we start with capacity 1, then go to capacity 2, then capacity 4, and so on).  How many operations would it take to add $N$ elements to the end of this array if you added them one-by-one and follow the strategy of doubling the capacity of the array each time you run out of space (for simplicity you can assume that $N$ is a power of 2)?  Determine $\\Theta$ of the time complexity of adding these $N$ elements in this fashion.  Show / Hide Hint  If you add up the time it takes to create each of these expanded arrays, what sort of series do you get?  How do you calculate the sum of this type of series?Linked ListsNext, we’re going to learn about a data structure that excels at many of the operations that arrays are slow at and lags behind in areas where arrays are fast.  This data structure is the linked list.A linked list is another way to represent an ordered collection of values.  Instead of storing our collection in a contiguous block of memory, instead we store data in nodes that each contain a value and a reference to both the next node and the previous node in our list (this sort of linked list is called a doubly linked list).  In addition to these nodes, we also maintain a reference to the first element (or the head of the linked list) and a reference to the last element (or tail of the linked list).  Let’s draw a picture of what this looks like on the board together. figure from geeksforgeeksNow let’s do some problems to understand the time complexity of various operations on our linked list.  For the purposes of these exercises, let’s assume that we can request memory to store a new linked list node in constant time ($\\Theta(1)$).  Exercise 5: With folks around you, determine the time complexity ($\\Theta$) of each of these operations on a linked list.  For each of these, make a list of the steps you’d have to do in order to accomplish each of these operations.  Count up the number of operations.  What is $\\Theta$ for this count?      Add an element to the beginning of the list    Delete an element from the beginning of the list    Add an element to the back of the list    Delete an element from the back of the list    Print out the middle element of the list    Exercise 6: A singly linked list is a linked list where each node only has a reference to the next element in the list.  In such a list, would the $\\Theta$ of any of these operations in problem 5 be different?  If so, which would be different and what are their new $\\Theta$ running times?sAbstract Data TypesA common strategy for managing complexity in software is to separate the details of how a piece of software works (the implementation) from the functions that the software performs (the interface).  You may have seen this when you encountered object-oriented programming in Software Design.  When you created Python classes, you would define methods on those classes that could then be called to perform some operation.  The details of how these operations were carried out, were opaque to the caller (e.g., another class in our program).  In our study of data structures, we will make a similar distinction between the operations that a data type performs, and the specific underlying data structure that is used to implement this data type.We call the specification of a set of operations (or semantics) for a data type an Abstract Data Type (or ADT).  For instance, we might specify an ADT to represent an ordered collection with the following operations:  Insert at a new element at position $i$  Delete element at position $i$  Access element at position $i$  Append an element to the end of the list  etc.The actual implementation of this abstract data type (called a concrete data type) could use a linked list or an array (or something more exotic) as the underlying data structure.  Determining what concrete data type to use to implement a specific ADT will depend on the operations are most important for your application (you’ll want to make those fast).  Perhaps, you could even create different implementations of the same ADT for different use cases (e.g., if you care about accessing elements quickly or adding new elements).  Exercise 7: For example, the Python tutorial on lists states that while accessing elements in the list, appending an element ot the end of the list, or removing an element from the end fo the list is fast, adding or deleting an element at the beginning of the list is slow.  Based on what you worked out earlier in class, what underlying concrete data structure do you think Python uses for its list class?  Do some research to see if you are right.Stacks vs. QueuesIn the next assignment, you will be implementing both a stack and a queue.  Each of these data structures will be built on top of a linked list, but stacks and queues will differ with respect to some of their behaviors.  Specifically, stacks use what is called a LIFO (last in first out) ordering whereas queues utilize a FIFO ordering (first in first out).  You’ll get a bunch of practice using your stacks and queues to solve problems in the assignment, but you might also want to check out this short article comparing the two data structures.Kotlin InterfacesLet’s learn about Kotlin interfaces and why they are a useful way to define abstract datatypes.Let’s say we want to design a simple 2D geometry library.  We may want to define the abstract datatype shape as one that supports a set of operations.  Perhaps each shape can compute its area and perimeter.  We can formalize this idea using a Kotlin interface.interface Shape {    fun area(): Double    fun perimeter(): Double}This interface is like a contract that any class that implement the Shape interface must fulfill.  For example, we could create a class called circle in the following way.class Circle(private val radius: Double) : Shape {    override fun area(): Double {        return Math.PI * radius * radius    }    override fun perimeter(): Double {        return 2.0 * Math.PI * radius    }}We might define a rectangle in the following way.class Rectangle(private val width: Double,                private val height: Double) : Shape {    override fun area(): Double {        return width*height    }    override fun perimeter(): Double {        return 2.0 * (width + height)    }}The nice thing is that we can write functions that operate on any class that implements this particular interface.fun totalArea(shapes: List&lt;Shape&gt;): Double {    return shapes.sumOf { it.area() }}This lets us do things like:fun main() {    println(        totalArea(listOf(Circle(5.0),                         Rectangle(2.0, 4.0)))    )}",
        "url": "/in_class/day03.html"
      },"in-class-day04-html": {
        "title": "Day 4: Stack Implementation Walkthrough and Challenge Problems",
        "author": "",
        "category": "",
        "content": "OverviewWe’re going to take some time to dive into an implementation of a data structure: the Stack.  We’ll get started together, and then I’ll let you all split off to work at your own pace.Closing the Loop on Abstract Datatypes and InterfacesLet’s talk through the last bit of the previous day together.Implementing a Stack TogetherWe’re going to go through the process of implementing a stack as a class.  Once we get through this example, we should have lots of time for folks to ask questions or keep working on the homework.The steps we will go through will involve creating a new project, creating a stack class, adding some basic functions, and testing our code through unit tests.The definition of the stack abstract datatype (ADT) can be defined using this Kotlin interface (this is directly from the current assignment).interface Stack&lt;T&gt; {    /**     * Add [data] to the top of the stack     */    fun push(data: T)    /**     * Remove the element at the top of the stack.  If the stack is empty, it remains unchanged.     * @return the value at the top of the stack or nil if none exists     */    fun pop(): T?    /**     * @return the value on the top of the stack or nil if none exists     */    fun peek(): T?    /**     * @return true if the stack is empty and false otherwise     */    fun isEmpty(): Boolean}Let’s create an implementation of this ADT together.  Note: in contrast to what you should do on the homework, which is to use a doubly linked list to create your stack, here we will implement the stack directly.A sample solution can be found in the course solutions repo.Additional Practice ProblemsIf you already feel good about implementing a stack.  Here are some suggestions for taking the material farther.  I invite those who are interested in this to move to MAC326 to work with others in that room.  Optional Exercise  Create a class called MutableStringList that implements the following Kotlin interface.  You should use Kotlin arrays to store the entries of the list and implement a strategy where you double the size of the underlying array when you run out of space (since we know from last time that this has better $\\Theta$ run time).  A sample solution for this optional problem (with unit tests left as an exercise to you all) is in the class sample solutions repo.  interface MutableStringList {    /**     * Adds [data] to the end of the list     */    fun add(data: String)    /**     * Returns the number of elements in this collection.     */    fun count(): Int    /**     * Return the element at the specified index     *     * @return the value if it exists.   The behavior is undefined if the value does not exist.     */    operator fun get(index: Int): String    /**     * Set the element at the specified index.  If the index does not exist, the behavior is undefined.     */    operator fun set(index: Int, value: String)}    As an additional challenge, show, through timing your code on values of $N$ of different orders of magnitude, that the cost to add $N$ elements to your mutable list is $\\Theta(N)$.  Optional Exercise  Building off the suggestions in the assignment, try some LeetCode-style problems taht use stacks, queues, or linked lists.",
        "url": "/in_class/day04.html"
      },"in-class-day05-html": {
        "title": "Day 5: Choose Your Own Adventure and Intro to Graphs",
        "author": "",
        "category": "",
        "content": "Assignment DebriefHow did things go?  With those around you, make a list of questions that you still have regarding the assignment content.  We’ll raise them to the group, and then I’ll work to resolve them.  If you have any aspects of the assignment that you enjoyed or aspects that could be better, please raise that as well.A Few Words About Null SafetyOne of the areas of Kotlin that provides a steep learning curve is dealing with optional values.  I sent out some resources that should give you a few strategies to deal with nullable types (types that end with a ?).  Some useful patterns are shown below (source: https://kotlinlang.org/docs/null-safety.html)// use smart casts so the compiler assumes a non-null type within the if statementval x: Int? = 2if (x != null) {    println(2*x)}There are some tricky situations where this pattern will not work.  In particular, when you are dealing with variables that are class attributes.  Let’s take a look at a version of our peek function from our stack.This code provides a cryptic warning from the compiler.    override fun peek(): T? {        if (top != null) {            return top.data        }        return null    }  Smart cast to ‘MyStack.StackNode&lt;T (of class MyStack)&gt;' is impossible, because 'top' is a mutable property that could be mutated concurrently.The reason for this error is that it’s possible your code could have multiple threads.  If you haven’t heard of multithreaded programming, no worries.  We aren’t going to be doing anything with it in this class, but conceptually you can imagine multiple tasks happening concurrently within your programming.  At the same time you are peeking onto the stack, another task could be modifying the stack in some way.  Due to this possibility, the compiler can’t be sure that top will be non-null by the time you enter the let.  A solution is to create a local variable first and use let on that.    override fun peek(): T? {        val currentTop = top        if (currentTop != null) {            return currentTop.data        }        return null    }If you want to make your code a little cleaner, you can define the local variable and the block of code to run if the expression is non-null in one go.  One way to do this is to use the let function.    override fun peek(): T? {        top?.let { currentTop -&gt;            return currentTop.data        }        return null    }You’ll continue to get more practice with nullable types as we go, but I wanted to provide you with some guidance around what is a fairly difficult to understand error.(Adventure 1) Kotlin Arrays and Creating Our Own Mutable List  This is a small extension of the challenge problem from last time.  I give this as an option to work on if you want more practice implementing data structures in Kotlin.  If you’d rather do more problem-solving with stacks and queues, you can skip to the next section.Kotlin has a built-in Array class (documentation) that can be used in much the same way as List (and mutable list).  The restrictions on Array mean that we can’t add elements to it.  Exercise 1: Using an Array as the underlying data structure, create a class called MyMutableIntList that can hold values of type Int (there a few hoops to jump through to make it hold any type, so let me know if you want to learn about that process).  Your class should support the following functions.  Note 1: the operator functions let you implement the same behavior that MutableList has in getting and setting elements (e.g., a[2] = 3).  Note 2: when you create your class, you will need to think about how to grow your array when you run out of space.  In class we did some analysis that seemed to show that multiplying the array size by $2$ when it is full is faster than growing it by 1 each time.interface MutableIntList {    /**     * Add [element] to the end of the list     */    fun add(element: Int)    /**     * Remove all elements from the list     */    fun clear()    /*     * @return the size of the list     */    fun size(): Int    /**     * @param index the index to return     * @return the element at [index]     */    operator fun get(index: Int): Int    /**     * Store [value] at position [index]     * @param index the index to set     * @param value to store at [index]     */    operator fun set(index: Int, value: int)}Timing your codeYou can add the following code to your main() function to see how efficient your class is for different list sizes.fun main() {    val arraySizes = listOf(100, 1000, 10000, 100000, 1000000, 10000000, 100000000)    println(\"numberOfElements totalTime timePerElement\")    for (arraySize in arraySizes) {        val myList = MyMutableIntList()        val timeTaken = measureTime {            for (i in 0..&lt;arraySize) {                myList.add(i)            }        }        println(\"$arraySize $timeTaken ${timeTaken/arraySize}\")    }}If you find it useful, you can use this link to access my solutions for this exercise.(Adventure 2) Solving Problems with Stacks and QueuesIf you’d prefer to get more practice solving problems with stacks and queues, here are some suggestions.  Exercise 2  Implement Stacks Using Queues   Show / Hide Hint 1           You do not need to maintain $\\Theta(1)$ runtime for all stack operations.     Exercise 3  Evaluate Reverse Polish Notation.  There are some embedded hints on this page.Intro to GraphsIn the next assignment we’re going to dive into the world of graphs and graph searching.  Before we do so, let’s take some time to understand what a graph is.Graphs are ways to represent relationships between entities of some sort.  Exercise 4: before we define some important vocabularly to talk about graphs, with those around you, come up with a couple examples of systems that fit this pattern. The systems you consider could be social, geographical, computer-based, informational, etc.To formalize this a bit more, we use the terminology of vertices or nodes to refer to the entities in our graph (e.g., the people or websites in our examples above).  We use the term edges to represent the relationships (e.g., the existence of a friendship or a link in our two examples above).  In graph theory and algorithms, there are many different types of edges (e.g., directed, undirected, weighted, multi-edges) to represent different sorts of relationships.For now, we’re going to consider the case of directed edges where an edge encodes a unidirectional relationship between two entities.  For example, a directed edge from the node olin.edu to google.com might represent that Olin’s website links to Google’s website.Before we get into the theory of graphs and the sorts of algorithms we might run on them, let’s introduce the concept of an adjacency list, which is a particular way to represent graphs in a computer program.  Note that this is not the only way to represent a graph in a computer program, but it is a very popular one.  Exercise 5: read about adjacency lists.  On a chalkboard (or piece of paper at your table) write out a plan for how you would implement an adjacency list in Kotlin.  Your plan might be fairly abstract (e.g., listing out particular classes and functions without worrying about syntax).  If you have time to translate this into Kotlin code, please do so.Specifications:  To represent your vertices, you could choose a particular type (e.g., String), or you could use generics to make it work for any class.  At a minimum, your class should support the ability to add new vertices, add new edges, and get the list of vertices that are connected to a given vertex.  Note: I expect there will be questions on this, so please don’t hesitate to call me over.",
        "url": "/in_class/day05.html"
      },"in-class-day06-html": {
        "title": "Day 6: Graph data structures, depth-first and breadth-first search",
        "author": "",
        "category": "",
        "content": "Adjacency ListsLast time, I asked you to think about the adjacency list, which is a particular way to represent graphs in a computer program.Let’s take a few minutes as a class to make sure we understand what we mean by adjacency list.To get us on the same page let’s use the following definition of a Graph.  We’ve made a small adjustment here to use sets instead of lists to represent our connections.class Graph&lt;VertexType&gt; {    private var vertices: MutableSet&lt;VertexType&gt; = mutableSetOf()    private var edges: MutableMap&lt;VertexType, MutableSet&lt;VertexType&gt;&gt; = mutableMapOf()    /**     * Add the vertex [v] to the graph     * @param v the vertex to add     * @return true if the vertex is successfully added, false if the vertex     *   was already in the graph     */    fun addVertex(v: VertexType): Boolean {        if (vertices.contains(v)) {            return false        }        vertices.add(v)        return true    }    /**     * Add an edge between vertex [from] connecting to vertex [to]     * @param from the vertex for the edge to originate from     * @param to the vertex to connect the edge to     * @return true if the edge is successfully added and false if the edge     *     can't be added or already exists     */    fun addEdge(from: VertexType, to: VertexType): Boolean {        if (!vertices.contains(from) || !vertices.contains(to)) {            return false        }        edges[from]?.also { currentAdjacent -&gt;            if (currentAdjacent.contains(to)) {                return false            }            currentAdjacent.add(to)        } ?: run {            edges[from] = mutableSetOf(to)        }        return true    }    /**     * Clear all vertices and edges     */    fun clear() {        vertices = mutableSetOf()        edges = mutableMapOf()    }}Graph TraversalOne of the most important graph algorithms is the concept of searching for a path that connects two nodes within a graph.  This concept is known as Graph Traversal or Graph Search.Within the space of graph traversal, there are a number of useful problems we might solve.  Shortest path (finding the path between two nodes with the least cost)  Traveling salesman problem  Hamiltonian path  Eulerian path  … (many more)In this class we will be mainly concerned with the shortest path problem.There are tons of problems that can be cast as graph traversal problems.  Let’s think of a few as a class.  To get us started what are some problems that can be converted into graphs?We’re going to learn about four different methods for graph traversal in this class: breadth-first search, depth-first search, Dijkstra’s algorithm, and A-Star search. Today, we’ll talk about the first two.Breadth-First Search (BFS)Starting from some node in our graph, let’s call it root, we want to keep following edges until we find our node target.  Our search proceeds by following all edges from the current node.  Once we’ve followed all of those edges, we follow edges from current to the next node, we follow edges from that set of nodes, etc. We do this until we find target or run out of nodes to visit.Depth-First Search (DFS)Starting from some node in our graph, let’s call it root, we want to keep following edges until we find our node target.  Our search proceeds by continuously following edges until we reach a point where no edges are available to traverse.  At that point, we can back track on our path and visit the next edge.General Approach to Graph TraversalOur algorithms for graph traversal are all fairly similar.  The two we’re going to learn about today can be described using the following framework.toVisit ← {}priorityList ← []priorityList.add(root)toVisit.add(root)while priorityList is not empty:    n ← priorityList.popHighestPriorityElement()    if n == target:        return true // path exists    for m in nodesConnectedTo(n):        if m is not in toVisit:            priorityList.add(m)            toVisit.add(m)return false // no path  Exercise 1:  Looking at the pseudocode above, what is the role of the variable toVisit?  What might happen if we removed it?  Exercise 2:Sometimes it’s also useful to be able to return the actual path that would be needed to go from the starting root to target.How could we modify the pseudocode to be able to return the path from root to target?   Show / Hide Hint           You may find MutableMap to be useful here.     Exercise 3:  Given the pseudocode above and the Graph class, implement breadth-first search (BFS).  You can choose how you define your function, but perhaps add it as a new function of Graph.  I recommend you start with some pseudocode before firing up IntelliJ.  Here is a potential function signature for bfs  /** * Search through a graph using a breadth-first search * @param start the node to start the search * @param target the node to search for * @return true if and only if path exists between [start] and [target] */fun bfs(start: VertexType, target: VertexType): Boolean    For added challenge, you can return the path from start to target (rather than just indicating if it is possible).  /** * Search through a graph using a breadth-first search * @param start the node to start the search * @param target the node to search for * @return the path from start to target (if one exists) and null otherwise*/fun bfs(start: VertexType, target: VertexType): List&lt;VertexType&gt;?    Show / Hide Hint           Think about which data structures you've learned about would achieve the desired prioritization of nodes.     Exercise 4:  Given the pseudocode above and the Graph class, implement depth-first search (DFS).  You can choose how you define your function, but perhaps add it as a new function of Graph.  I recommend you start with some pseudocode before firing up IntelliJ.  Here is a potential function signature for dfs  /** * Search through a graph using a depth-first search * @param start the node to start the search * @param target the node to search for * @return true if and only if path exists between [start] and [target]*/fun dfs(start: VertexType, target: VertexType): Bool    For added challenge, you can return the path from start to target (rather than just indicating if it is possible).  /** * Search through a graph using a depth-first search * @param start the node to start the search * @param target the node to search for * @return the path from start to target (if one exists) and null otherwise*/fun dfs(start: VertexType, target: VertexType): List&lt;VertexType&gt;?    Show / Hide Hint           Think about which data structures you've learned about would achieve the desired prioritization of nodes.   Visualizations of Graph TraversalHere are some resources for visualizing graph searching algorithms.  Stanford SAILORS tutorial on breadth-first search  Stanford SAILORS tutorial on depth-first search  Stanford SAILORS tutorial on comparing DFS and BFSGraph PropertiesWe probably won’t have a ton of time to work with these during class today, but here are some useful properties of graphs.  If you have time, go ahead and implement (either in pseudocode or Kotlin) one or more of them.Number of Connected ComponentsFor an undirected graph (where A connected to be B is implies B connected to A), a connected component is a set of vertices such that there is a path between any two vertices in the set.  If all vertices in a graph are connected, we would say the graph has 1 connected component.  On the other hand, if there are some vertices that are not reachable from each other, that would create additional components.Suppose you were given a Graph object where you were guaranteed that all edges were symmetric (A connected to B implies B connected to A).  Write pseudocode to determine the number of connected components in your graph.DAGs (Directed, Acyclic Graph)A directed graph is acyclic if it contains no cycles.  A cycle is a path that starts at a given node and returns to that same node.There are several algorithms to determine if a graph is a Directed Acyclic Graph (DAG).  One of the easier ones to understand is Kahn’s algorithm, which has the following description from the Wikipedia page on Topological Sorting. It turns out that a graph is a DAG if and only if there is a valid topological sorting of the nodes in the DAG.L ← Empty list that will contain the sorted elementsS ← Set of all nodes with no incoming edgewhile S is not empty do    remove a node n from S    add n to L    for each node m with an edge e from n to m do        remove edge e from the graph        if m has no other incoming edges then            insert m into Sif graph has edges then    return error   (graph has at least one cycle)else     return L   (a topologically sorted order)TreesAn undirected graph is a tree if there is exactly one path between any pair of nodes.  This is guaranteed if the graph is connected and the total number of edges if equal to the number of vertices minus 1.A directed graph is a tree if it is acyclic and the graph the results from making the edges undirected is a tree.Sample SolutionsSample solutions for today are in the Github repo as a module.",
        "url": "/in_class/day06.html"
      },"in-class-day07-html": {
        "title": "Day 7: DAGs, Dijkstra&apos;s Algorithm, and Heaps",
        "author": "",
        "category": "",
        "content": "A Few Things Regarding the Current Assignment  I added a tips and tricks section (currently just one there). Let me know if you want me to add anything to it.  I added an assignment submission checklist to the Canvas pageDirected-Acyclic GraphsA directed graph is acyclic if it contains no cycles.  A cycle is a path that starts at a given node and returns to that same node.  We use the acronym DAG (directed, acyclic graph) to refer ot this type of graph.  Here is an example of such a graph.graph LR  A --&gt; B  B --&gt; C  A --&gt; C  C --&gt; D  B --&gt; D  A --&gt; EAs was included in the day materials last time (although there was not enough time to get to it), there are several algorithms to determine if a graph is a DAG.  One of the easier ones to understand is Kahn’s algorithm, which has the following description from the Wikipedia page on Topological Sorting. It turns out that a graph is a DAG if and only if there is a valid topological sorting of the nodes in the DAG.  A topological sorting of a directed graph consisting of vertices $V$ and edges $E$ consists of an ordering of the vertices $v_1, v_2, \\ldots, v_n$ such that the edge $v_i \\rightarrow v_j$ exists in $E$ if and only if $i &lt; j$.Let’s work as a class to determine a valid topological sorting of the graph above.  Is the sorting unique?Show Solution     A valid solution would consist of the order $A, E, B, C, D$.  For this graph, another valid topological sorting would be $A, B, C, D, E$.  (other sortings exist as well)Kahn’s algorithm can be used to determine if a directed graph has cycles or not.  The pseudocode for Kahn’s algorithm is below.L ← Empty list that will contain the sorted elementsS ← Set of all nodes with no incoming edgewhile S is not empty do    remove a node n from S    add n to L    for each node m with an edge e from n to m do        remove edge e from the graph        if m has no other incoming edges then            insert m into Sif graph has edges then    return error   (graph has at least one cycle)else     return L   (a topologically sorted order)Let’s go through this example together to see how Kahn’s algorithm works.Let’s try Kahn’s algorithm on a graph that does contain a cycle to see what happens.Input graph:graph LR  A --&gt; B  B --&gt; C  C --&gt; D  C --&gt; B  A --&gt; D$L = []$, $S = [A]$After step 1:$L = [A], S = []$graph LR  A  B --&gt; C  C --&gt; D  C --&gt; BQuestion for us to work through together: How would we prove that Kahn’s algorithm is correct?Dijkstra’s AlgorithmI have some companion slides to go along with the presentation of Dijkstra’s algorithm.  I’ll have these up on the projector, but you can access the slides in PPTX or PDF form.  Don’t pull them up just yet.Before we introduce Dijkstra’s algorithm, we need to briefly introduce the idea of weighted graphs.  Imagine that in addition to storing the neighbors of each vertex in our graph, we also store an edge weight.  Here is what a graph might look like with edge weights added.graph LR  A --2--&gt; B  B --3--&gt; C  A --4--&gt; C  C --3--&gt; D  B --1--&gt; D  A --10--&gt; E  D --7--&gt; EAs an aside, edge weights could encode a bunch of different things in our graph.  In computer vision, edge weights can encode the dissimilarity between neighboring parts of an image and this graph can then be processed to segment the image into regions.  Another classical example is graph traversal where we might want to find the shortest path through a graph connecting $v_{start}$ to $v_{goal}$. In this setting, the cost of a path is defined by the sum of edge weights along the path.  This is what we will learn about next.Dijkstra’s algorithm gives us a way to compute the shortest path (defined in terms of the lowest sum of edges) to move between a given source node and any destination node.  In order for Dijkstra’s algorithm to work, none of the edges in the network can have a negative weight (or cost).Looking at our sample graph, let’s calculate a few shortest paths.Dijkstra’s algorithm gives us a way to compute the shortest path in a systematic fashion.  The pseudocode for the algorithm is defined below.  Before we go through the algorithm, let’s make sure we understand the role of two maps (or, if you prefer, dictionaries) that we will be creating.  The first is called prev and it is used to reconstruct the shortest path once we find it.  The second is called dist and you can think of this as a tentative cost to travel from the start node to any particular node.  We’ll also maintain a queue of nodes that we plan to visit.  This queue will be pretty similar to the one you implemented on the last assignment, but it will have an additional feature of adding elements with a particular priority.for each vertex, v that is not the source:    prev[v] ← UNDEFINED    dist[v] ← INFINITY    queue.addWithPriority(v, INFINITY)dist[source] ← 0queue.addWithPriority(source, 0)while queue is not empty:    u ← vertex in queue with min priority    remove u from queue    for each neighbor v of u still in queue:        alt ← dist[u] + edgecost(u, v)        if alt &lt; dist[v]:            dist[v] ← alt            queue.changePriority(v, alt)            prev[v] ← u// reconstruct shortest path from prevNow that we’ve seen this pseudocode, let’s go through our slides to see an example of it in action.  Exercise 1  (a) How does this pseudocode differ from the approach we used last class (for DFS and BFS)?  (b) Suppose the pseudocode above has finished running, how would you reconstruct the shortest path from the vertex source to a vertex target using prev?Min-HeapsA binary heap is a data structure that is very useful for implementing the priority queue will need for Dijkstra’s algorithm.A heap is a special type of graph called a binary tree.Definition A tree is a graph where there is a root node (one that has no incoming edges) and each vertex, besides the root, has exactly one incoming edge.  For a given node, $v$, if there exists an edge $p \\rightarrow v$ we call $p$ the parent of $v$.  Nodes with no outgoing edges are called leaves.  The maximum length path (defined in terms of number of edges) from the root to any leaf is called the height of the tree.Definition A binary tree is a tree where each node has at most two outgoing edges.  For a vertex, $v$, if $v \\rightarrow u$ and $v \\rightarrow q$ then we say that $u$ and $q$ are children of $v$. Sometimes we think of these children as ordered, and we’ll refer to them as the left or right child of $v$.An example of a binary tree is given below.graph TB  A --&gt; B  A --&gt; C  B --&gt; D  B --&gt; E  C --&gt; F  C --&gt; GA heap extends the concept of a binary tree by adding a number that accompanies each node.  Let’s suppose in our example that each of the letters A through F in our sample graph above were assigned the following values (A: 5, B: 3, C: 4, D: 9, E: 1, F: 6).  The following would be a valid heap.graph TBE[E, 1] --&gt; B[B, 3]E --&gt; C[C, 4]B --&gt; A[A, 5]B --&gt; F[F, 6]C --&gt; D[D, 9]  The binary tree above is a heap because it meets two conditions.  Condition 1 the binary tree maintains the “heap-invariant”, which is that for any two nodes, $u, v$ in the tree such that the edge $u \\rightarrow v$ the number stored with $u$ is less than the number stored with $v$.  In plain-speak, for any node in the graph the number written next to it will be less than the numbers written next to any nodes below it.  Condition 2 the binary tree is nearly complete meaning that it has the minimum height for a tree with the specific number of nodes.Implementation: Inserting an element into the heapWhen inserting an element into the heap, we put it in the tree at the lowest level in the first available spot (starting from the left).  Once we place it in the heap, we check to see if this placement has violated the heap invariant (condition 1).  If so, we swap the node with its parent.  We the nodes new parent to make sure the heap invariant is satisfied (swapping if it’s not) and so on.  This procedure is called “bubbling up”.We’ll do a quick example of bubbling up on the board.Implementation: Finding the vertex with the minimum corresponding numberThis is super easy!  We just look at the root node.  It’s guaranteed to be the minimum.  Quick understanding check: why is that?Implementation: Removing the minimumTo remove the minimum value we first replace the root node with the right most element of the lowest level of our tree.  We then perform a procedure called “bubbling down” where we check to see if the new root violates the heap invariant (condition 1).  If it is larger, then we swap it with the child with the smaller number.  After the swap we continue bubbling the element down until it no longer violates the heap invariant (condition 1).We’ll do a quick example of bubbling down on the board.Binary Heap Operations ComplexityNow that we know what a heap is, let’s talk about the running time of various operations on a heap.            Operation      Runtime                  Insert      $\\Theta(\\log n)$              Delete min      $\\Theta(\\log n)$              Find min      $\\Theta(1)$        Exercise 2 Why are these runtimes attractive from the perspective of implementing Dijkstra’s algorithm?  Exercise 3 What operation needed for Dijkstra’s algorithm is not present in the list above?  How would you implement it?  Exercise 4 Show why delete min, insert, and change heap number are all $\\Theta(\\log n)$.Implementation considerationsSince this is part of the extra credit, I’ll leave it to you to look into the details of this (there’s a lot of explanations on the web / videos to watch).  Binary heaps are often implemented by storing the vertices of the heap in a list.  This might seem counterintuitive, but it presents a really elegant solution to some challenging aspects of implementing the heap: finding parents and children of a node, quickly swapping nodes in the tree, and inserting new values in such a way that condition 2 is maintained.",
        "url": "/in_class/day07.html"
      },"in-class-day08-html": {
        "title": "Day 8: A-Star Search and Intro to Sorting",
        "author": "",
        "category": "",
        "content": "A quick reminder about GenAI policy  If you feel it is consistent with what helps you learn, you may use generative AI tools (e.g., ChatGPT) to help you complete the work in this course.  When using these tools, please disclose how you used generative AI in preparing your work.  Please do not use generative AI in a way that makes your contribution to the work negligible.  The design of the oral quizzes is designed around idea that you should be able to explain how the code that was created by generative AI works and what each line is doing.  You might also strive to be able to rewrite the code without generative AI.How fast is Dijkstra?Let’s start with an easy to state, but not so easy to answer problem.  Exercise 1  What is the runtime complexity ($\\Theta$) of Dijkstra’s algorithm?  Your answer should be in terms of the number of nodes $n$ and the number of edges $m$.A-Star SearchBefore we turn the page to the next topic of the course, sorting, I want to talk about a really another graph traversal algorithm, A-star search.What’s beautiful about a-star search is that it can drastically speed up dijkstra’s algorithm in certain cases by cutting down on search certain paths.Before showing the algorithm, we should realize that A-star is solving a bit different problem than Dijkstra’s.  A-star is specifically solving finding a path from a given start vertex to the goal (rather than to any possible destination as we did in Dijkstra’s).The key insight of A-star is to make use of a heuristic function that serves as a lower in terms of the cost to move from a particular node in the graph to the goal.  Let’s do some work at the board to understand what a heuristic means and under what conditions it can work with A-star (this is known as the admissibility condition).We use the notation $h(v)$ denotes the lower bound on traversing from $v$ to the goal node.  Given this construction, we can modify our pseudocode for Dijkstra’s algorithm from last time to get the A-star algorithm.Before stating our pseudocode, let’s define what each variable in the program will represent.  source is our starting vertex in the graph for searching  goal is the vertex we are trying to reach  prev will be used to reconstruct the optimal path and will map from a vertex to the vertex immediately preceding it on the optimal path from source to goal.  dist maps from a vertex to the currently known minimum cost path from the start to that vertex  queue is our priority queue that we will use to keep track of which vertex to expand nextfor each vertex, v that is not the source:    prev[v] ← UNDEFINED    dist[v] ← INFINITYdist[source] ← 0    // note: this is called g in some writeupsqueue.addWithPriority(source, h(source))while queue is not empty:    u ← queue.popMin()  // gets min and removes it    if u == goal:        // reconstruct shortest path from prev        return    for each neighbor v of u:        alt ← dist[u] + edgecost(u, v)        if alt &lt; dist[v]:            dist[v] ← alt            if v in queue:                queue.changePriority(v, alt + h(v))            else:                queue.addWithPriority(v, alt + h(v))            prev[v] ← uKey differences with Dijkstra’s algorithm.  In A-star, nodes can be expanded multiple times (in Dijkstra’s they can only be expanded once)  We make use of a heuristic function to prioritize our search (this can save us time)Example to do on the board (this is from Pieter Abbeel’s course at Berkeley):graph LR  S --1--&gt; A  S --4--&gt; B  A --5--&gt; C  A --2--&gt; B  B --2--&gt; C  C --3--&gt; G  A --12--&gt; GThis graph has the following heuristic.            Vertex      h              $S$      7              $A$      6              $B$      2              $C$      1              $G$      0      Let’s try to understand why this could make your problem more efficient.SortingThe sorting problem typically involves taking an input list of items and rearranging them so that the resultant list contains the items in some order.  A simple example would be arranging numbers in ascending order.  There are many variants and settings to this problem, but for this part of the class, let’s imagine that we are simply taking lists of integers and sorting them in ascending order.We’re going to learn about three of the many sorting algorithms today.Selection sortSelection sort is a very simple algorithm.  We continuously look for the minimum value in the part of the list that is unsorted and then place that element at the front.  Let’s develop the pseudocode for this and prove that the algorithm yields a sorted list.  You can see a visualization of this algorithm by going to visualgo.net/en/sorting and choosing selection sort.Merge sortMerge sort is a divide and conquer approach to sorting a list.  We’ll develop some pseudocode for this one together.The basic idea is to chop our list in two, sort both halves, and then reassemble the two sorted halves into a sorted whole.  You can see a visualization of this algorithm by going to visualgo.net/en/sorting and choosing merge sort.Heap sortThis one is pretty awesome.  You just insert all of your values into a binary min heap and then take them all out using the getMin() function.Complexity of Sorting Algorithms  Exercise 2: Analyzing Selection Sort  Let’s start as a group by analyzing the worst case running time of selection sort.  Compute the number of operations necessary to run selection sort in the worst case.  Determine $\\Theta$.Analyzing Heap Sort  Exercise 3: Determine the $\\Theta$ of heap sort.Analyzing Merge Sort  Exercise 4: Determine the $\\Theta$ of merge sort by drawing a tree diagram that shows how the problem of size $n$ is divided into subproblems (this will form a tree).  Keep track of how much work you would do at each level of this tree.Master TheoremA generalizable recipe for analyzing recursive algorithms like this is the master theorem.  Exercise 5: Reanalyze merge sort using the master theorem.You may find the following special cases of the master theorem useful (we’ll discuss the more general form next class).$T(n) = a T(n/b) + n$Has a run time $\\Theta(n^{\\log_{b}{a}})$ if $\\log_{b}{a} &gt; 1$.Has a run time $\\Theta(n \\log^{k+1} n)$ if $n^{\\log_{b}{a}} \\log{k} = \\Theta(n)$.",
        "url": "/in_class/day08.html"
      },"in-class-day09-html": {
        "title": "Day 9: More Sorting and More Divide and Conquer",
        "author": "",
        "category": "",
        "content": "Oral QuizzesOur first oral quiz will be assigned next Thursday (the 9th) and due the Thursday after that.  This is not at all required, but I will open up some practice spots for people if they want to get a flavor for what the oral quizzes will be like.  Look for those to be posted tomorrow and be scheduled for early next week.Class OverviewLast class we saw heap sort, merge sort, and selection sort, but there are many more to learn about. Today we’ll learn a few more sorting algorithms, but we’ll also formally introduce the master theorem as a generalizable way to find $\\Theta$ for divide and conquer algorithms.  There’s an optional section at the end on the speed limit of sorting (if you are interested).  That content is not part of the assignments or oral quizzes.Master TheoremA generalizable recipe for analyzing divide and conquer algorithms is the master theorem.  Remember, by divide and conquer all we mean is that we divide the problem into smaller subproblems, solve the subproblems recursively, and use the solutions to the subproblems to determine the solution to the original problem.Let’s see if we can apply this to determining the complexity of merge sort from last class.  Before applying the master theorem, we need to make sure we are comfortable with the idea of a recurrence relation.  A recurrence relation relates the runtime of an algorithm on input of size $n$ (denoted as $T(n)$) to the runtime of the algorithm on smaller problem sizes (less than $n$).  For example, in the case of merge sort we can write the following recurrence relation.  $T(n) = 2 T(\\frac{n}{2}) + n$Let’s make sure we understand this exactly.  The term on the left is the runtime of sorting $n$ items with merge sort.  The runtime is based on two parts.  The first part is the recursive piece, which consists of merge sorting two lists of size $\\frac{n}{2}$.  The second part is the work needed to reassemble the sorted lists back into an overall sorted list (the merge step), which takes time $n$.The master theorem provides a recipe for us to solve this recurrence relation (meaning determine a function $T(n)$ that satisfies the equation).  The master theorem solves recurrence relations of the following form.  $T(n) = a T(\\frac{n}{b}) + f(n)$You should see that for merge sort, $a=2$, $b=2$, and $f(n) = n$.In order to apply the master theorem, we compute a value called $c_{crit} = \\log_{b}{a}$.  Plugging in $a=2$ and $b=2$, we get $c_{crit} = \\log_2{2} = 1$.Now, we have to determine which of the three cases of the master theorem applies. Before doing so, let’s remember our order of growth.  Refresher: $O, \\Omega, \\Theta$  Let’s make sure we remember what our old friend $O$, $\\Omega$, and $O$ mean.  I’ll state these definitions somewhat loosely, trusting you to go back to the original definitions for the exact meanings.      $f(n) = O(g(n))$ means that $g(n)$ bounds $f(n)$ from above for large $n$.    $f(n) = \\Omega(g(n))$ means that $g(n)$ bounds $f(n)$ from below for large $n$.    $f(n) = \\Theta(g(n))$ means that $g(n)$ bounds $f(n)$ from both above and below (meaning $f(n) = O(g(n))$ and $f(n) = \\Omega(g(n))$).  Okay, so here are the three cases of the master theorem.  I’ll list the condition, state if merge sort meets it, and if it does, show the runtime.  To apply this to other problems, you will need to look back at the more general versions of these cases.Case 1: $n = O(n^c)$ for some $c &lt; 1$.  Nope can’t be true.  If $c$ is less than 1, it grows more slowly than $n$ and cannot be bound it from above.Case 2: $n = \\Theta(n (\\log n)^k)$ for some $k \\geq 0$.  Yes!  If we set $k=0$, then the $\\log$ drops out, and we are left with $n = \\Theta(n)$, which is true.Case 3: $n = \\Omega(n^c)$ for some $c &gt; 1$.  Nope.  If we set $c$ bigger than 1, it will grow faster than $n$ and won’t bound $n$ from below.Okay, so case 2 is the winner.  The runtime as dictated by case 2 is $T(n) = \\Theta(n^{c_{crit}} (\\log n)^{k+1}) = \\Theta(n \\log n)$ (since $c_{crit} = 1$ and $k = 0$).  Exercise 1: Reanalyze binary search using the master theorem.  Hint: first find a recurrence relation, and then try to find the case that matches.At first the formulas for the master theorem might seem a bit strange, but one quantity that comes up $n^{c_{crit}}$ is related to the number of nodes in the recursive tree when you apply a divide and conquer strategy.  For example, if we had $a = 4$ and $b=2$, the following tree would have approximately $n^2$ nodes.graph TD  r[n] --&gt; b[n/2]  r --&gt; c[n/2]  r --&gt; d[n/2]  r --&gt; f[n/2]  b --&gt; g[n/4]  b --&gt; h[n/4]  b --&gt; i[n/4]  b --&gt; j[n/4]  c --&gt; k[n/4]  c --&gt; l[n/4]  c --&gt; m[n/4]  c --&gt; n[n/4]  d --&gt; o[n/4]  d --&gt; p[n/4]  d --&gt; q[n/4]  d --&gt; s[n/4]  f --&gt; t[n/4]  f --&gt; u[n/4]  f --&gt; v[n/4]  f --&gt; w[n/4]  Exercise 2: Choose a few problems from the homework and do them together.  If you want to hit each case at least once, try these three.      Problem 1-5    Problem 1-21    Problem 1-23  Quick SortQuick Sort is one of the most commonly used sorting algorithms.There are quite a few ways to implement Quick Sort, but the general idea is the following:  For an unsorted list, choose an element of the list as your pivot value, $p$.  Iterate through the elements of your list ($x_1, x_2, \\ldots, x_n$), swapping as needed, until the pivot element is located at index $i$ and $x_j &lt; x_i$ if $j &lt; i$ and $a_j \\geq a_i$ if $j \\geq i$.  Sort range of elements that are before the pivot in the list and those after the pivot recursively.Let’s look at the algorithm visualization (you can choose quick or quick sort or random quick sort).Analyzing the runtime of this algorithm is a bit tricky.  Let’s consider a specific case of always choosing the first element as the pivot.  Let’s see what happens with quick sort with this pivot selection rule.Radix SortRadix sort (also called bucket sort) is an interesting algorithm where we don’t perform an explicit comparisons between elements in our list.  We instead sort, e.g. if we are sorting integers, based on comparing the ones digits, then the tens digit, etc.  Let’s check out the visualization of Radix sort at our favorite website!  Choose Rad, and then click the sort button.The complexity of radix sort is $\\Theta(nk)$ where $k$ is the number of digits (or chunks) that each element can be broken into (e.g., if our list had numbers with 4 or fewer digits, $k$ would be $4$).The Speed Limit for Comparison-Based Sorting  This is an optional writeup for those that are interested in going through the details.  To understand this, you need to know some basic facts from discrete math.  I’ll highlight those in the writeup.  I will not be going over the details in class.There’s a theorem that states that any algorithm for sorting that works by comparing elements of the list to each other has running time of $\\Omega(n \\log n)$ (that is the running time can be bounded below by $n \\log n$).  We can think of this as a speed limit for any sorting algorithm that relies on comparisons.The basic idea is to think about the problem of sorting a list of $n$ items a bit differently.  Instead of thinking of reordering the items such that the list is sorted, let’s think about sorting as the problem as determining a function that maps indices from the unsorted list to where they should go in the sorted list.  Here’s an example.Suppose we have a list $x = [3, 9, 2, 10]$.  We can think of a function that sorts the list as specifying a mapping from the original indices ($0, 1, 2, 3$) to their positions in the sorted list.  A function $f$ that achieves this could be defined as follows.\\[\\begin{align*}f(0) &amp;= 1,~\\text{since 3 would appear at index 1 in the sorted list} \\\\f(1) &amp;= 2,~\\text{since 9 would appear at index 2 in the sorted list} \\\\f(2) &amp;= 0,~\\text{since 2 would appear at index 0 in the sorted list} \\\\f(3) &amp;= 3,~\\text{since 10 would appear at index 3 in the sorted list}\\end{align*}\\]With this new definition of sorting in mind, let’s think about how many possible function $f$ there are as a function of $n$.  To determine this, we can imagine that for $f(0)$ there are $n$ possible choices, for $f(1)$ there are $n-1$ possible choices (since we can’t repeat what we chose for $f(0)$), for $f(2)$ there are $n-2$ possible etc.  Overall, we have that the number of choices is $n (n-1)(n-2)\\ldots 1 = n!$.  If you took Discrete, you might recognize this as the number of ways to permute $n$ items (which should line up intuitively with what we are doing here).Now let’s think about what happens when we perform some comparison $x_i &lt; x_j$ for the purposes of determining which of the $n!$ permutations will sort our list.  Some proportion will return true to this comparison the others will return false.  By this logic, if you think of the worst case scenario (which is what we consider when thinking about runtime complexity), at best we are left with half as many possible permutations that we are still considering (as compared to before the comparison).Let’s say each of our sorting algorithm  perfectly divides the number of possible permutations that are consistent with each comparison it performs. We can represent this scenario as a tree where at each level of the tree we perform a comparison to try to eliminate some of the $n!$ possible permutations.  The number written on the node in the tree represents the number of permutations that are still under consideration after performing a particular comparison.graph TD  r[n!] --&gt; b[n!/2]  r --&gt; c[n!/2]  b --&gt; e[n!/4]  b --&gt; f[n!/4]  c --&gt; g[n!/4]  c --&gt; h[n!/4]If we were to extend this tree, eventually we would reach leaf nodes where there are exactly $1$ permutation remaining (this would allow us to sort our list).  What is the runtime of this sorting algorithm?  Well, it has to be the number of comparisons, which is given by the height of the tree.  The height of the tree would be $\\log_2(n!)$ (since each level reduces the number of consistent permutations by a factor of $2$).  This shows that the fastest sorting algorithm based on comparisons has to perform at least $\\log_2(n!)$ operations in the worst case.  We could stop here, but we’d like to derive our desired result that states that all sorting algorithms are $\\Omega(n \\log n)$.To accomplish our goal, we now show that $\\log_2(n!) = \\Omega (n \\log n)$.  To do this we need to find a value $n_0$ and a constant $c$ such that $\\log_2(n!) &gt; c n \\log_2 n$ for $n \\geq n_0$.  Note: I’m using $\\log_2$ here to make it clearer in the proof coming up, but the base of the log doesn’t matter since it’s just a constant factor (that doesn’t affect $\\Omega$).The first fact we use is that $n! &gt; \\left(\\frac{n}{2}\\right)^\\frac{n}{2}$.  This is because the first $\\frac{n}{2}$ terms of $n!$ are all bigger than $\\frac{n}{2}$.\\[\\begin{align*}\\log_2(n!) &amp;&gt; \\log_2\\left (\\frac{n}{2} \\right)^\\frac{n}{2}\\\\&amp;= \\frac{n}{2} (\\log_2(n) - 1) \\\\&amp;\\geq c n \\log_2(n), \\text{for }n\\geq 4, \\text{and }c=\\frac{1}{4}\\end{align*}\\]That’s it!  We’ve shown that $\\log_2(n!) = \\Omega(n \\log_2 n)$, and we have proven our speed limit.",
        "url": "/in_class/day09.html"
      },"in-class-day10-html": {
        "title": "Day 10: Divide and Conquer and Intro to Dynamic Programming",
        "author": "",
        "category": "",
        "content": "Draft of Oral Quiz 1I have posted the tentative structure for the oral quiz on Canvas.  Please review it and discuss with those around you.  I’ll take some comments, and then finalize it in the next day or so.  The assignment will start on Thursday, October 9th and be due on Thursday, October 16th.Divide and Conquer and Intro to Dynamic ProgrammingToday is going to primarily be about getting practice with divide and conquer algorithms.  We’ll also throw in a recursive algorithm that doesn’t quite fit the mold of divide and conquer.  Exercise 1  Multiplying square matrices.  Given two square matrices, $A$ and $B$, each of size $n \\times n$.  Determine a divide and conquer method for determining the product of the two matrices $C = AB$.  To solve the problem, you can make use of the technique of block matrix multiplication.  Show that the running time you get from using block matrix multiplication is the same as you get from the traditional method of matrix multiplication (the one you learned about in math class).  Exercise 2  Create a divide and conquer algorithm to compute $x^n$ where $n$ is a positive integer.  Consider each multiplication operation as taking $\\Theta(1)$.  What is the runtime of your divide and conquer algorithm?  Hint: you should be able to do better thant $\\Theta(n)$.  How does it compare to the approach of just multiplying $x$ $n$ times.  Exercise 3  Solve the maximum contiguous subsequence problem by determining a divide and conquer algorithm to solve it.  Once you have the algorithm, use the master theorem to determine its runtime.  Note that there are other algorithm you can use to solve this problem (that are actually faster, but here we want to focus on divide and conquer).  The maximum contiguous sub-sequence problem involves taking an input list of numbers $x_1, \\ldots, x_n$ and determining two index values $i$ and $j$ such that $\\sum_{k=i}^j x_k$ is as large as possible.  Note that the numbers can be negative.  For simplicity, you can just return the maximum sum (rather than the indices).  Show / Hide Hint 1           Divide the array into two halves.  Find the maximum subsequence for each half.  What case have you not considered?     Show / Hide Hint 2           Create a special purpose algorithm for determining the maximum crossing sequence.   Dynamic Programming  Let’s start with a very simple recursive function and see if we can use dynamic programming to solve it.  Let’s implement a function to compute the $n$th Fibonacci number.We’ll see if we can understand how this applies to the Leetcode problem of Minimum Cost Climbing Stairs.The book “Introduction Algorithms” by Cormen, Leiserson, Rivest, and Stein has the following description of the dynamic programming approach.  Characterize the structure of an optimal solution.  Recursively define the value of an optimal solution.  Compute the value of an optimal solution, typically in a bottom-up fashion.  Construct an optimal solution from computed information.This can be a helpful way to think about dynamic programming.  Try it on the next problem.  You are given an integer array cost where cost[i] is the cost of $i$th step on a staircase. Once you pay the cost, you can either climb one or two steps.You can either start from the step with index 0, or the step with index 1.Return the minimum cost to reach the top of the floor.  Example 1:      Input: cost = [10,15,20]    Output: 15    Example 2:      Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]    Output: 6    Exercise 4:  Change making.  Given $n$ different coin denominations worth $x_1, x_2, \\ldots, x_n$ cents and a target value of $D$ cents, determine how many different ways you can combine the different coins to add up exactly $D$ cents.  You can use as many of each denomination of coin as you’d like.  Solve the problem using dynamic programming where you create a table to store the solutions to the problem, fill out rows and/or columns of the table that correspond to small or easy to solve instances of the problem, and then determine a rule for filling out the rest of the table.  Finally, determine how you would compute the solution to your original problem by referencing a particular cell in your table.",
        "url": "/in_class/day10.html"
      },"in-class-day11-html": {
        "title": "Day 11: More Dynamic Programming",
        "author": "",
        "category": "",
        "content": "Oral Quiz 1First, sign up for a time to meet with me (see link on Canvas).  You need to make it to this time unless something catastrophic happens.Here are some things I noticed in the practice quizzes.  When determining runtimes (non divide and conquer), figure out what are the main steps you have to perform, determine how many operations each step takes, and then add up the total number of operations.  Conclude by converting to $\\Theta$.  For divide and conquer algorithms, be ready to draw a tree diagram or use the master theorem.  When reading code, I found that people who talked through what the code as doing in greater detail had an easier time giving the relevant details.  For graph search (e.g., Dijkstra), make sure you understand what the variables represent (e.g., dist[v] returns the shortest known path from the source to vertex v).Dynamic Programming General StructureThe book Introduction Algorithms by Cormen, Leiserson, Rivest, and Stein has the following description of the dynamic programming approach.  Characterize the structure of an optimal solution.  Recursively define the value of an optimal solution.  Compute the value of an optimal solution, typically in a bottom-up fashion.  Construct an optimal solution from computed information.Practice Problems(You won’t be able to do all of these.  This is just for reference.  Turn in what you’d like.)  Exercise 1  Change making.  Given $n$ different coin denominations worth $x_1, x_2, \\ldots, x_n$ cents and a target value of $D$ cents, determine the minimum number of coins you can use to add up exactly $D$ cents.  You can use as many of each denomination of coin as you’d like.  Solve the problem using dynamic programming where you create a table to store the solutions to various subproblems, fill out rows and/or columns of the table that correspond to small or easy to solve subproblem, and then determine a rule for filling out the rest of the table.  Finally, determine how you would compute the solution to your original problem by referencing a particular cell in your table.  Bonus question (if you have time): can you modify your approach to count the number of ways you can make change for $D$ cents.  Exercise 2  The Longest Common Subsequence (LCS) problem asks: given two sequences, what is the longest sequence that appears in both of them in the same order? In other words, it’s the longest sequence that you can form by deleting some elements (without changing the order) from each of the two original sequences.  Exercise 3  Revisit the maximum contiguous subsequence problem from last class.  Instead of using divide and conquer, use dynamic programming.  Solution 3:    Exercise 4  In the 0–1 Knapsack problem, we are given a set of items, each with a weight and a value, and we need to determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible.  Please note that the items are indivisible; we can either take an item or not (0-1 property). For example,  Input:      value = [ 20, 5, 10, 40, 15, 25 ]    weight = [ 1, 2, 3, 8, 7, 4 ]    W = 10    Output: Knapsack value is 60 value = 20 + 40 = 60 (weight = 1 + 8 = 9 &lt; W)",
        "url": "/in_class/day11.html"
      },"in-class-day12-html": {
        "title": "Day 12: Dynamic Programming Wrapup and Starting Our Deep Dive",
        "author": "",
        "category": "",
        "content": "More Practice With Dynamic ProgrammingFor the first half of class you can either work on assignment 5 or try some more dynamic programming problems.  You may not have finished the problems from last time, so feel free to do those.  You can also look for additional problems, by searching for terms like “dynamic programming sample problems”.  You will get some like:  Longest Increasing Subsequence  Matrix Chain MultiplicationLooking Towards Assignment 6Assignment 6 will be a fairly short, self-directed project.  Use this link to find the details of assignment 6.  Let’s take the rest of class to formulate some initial ideas for this assignment.  We’ll also take some time to do some sharing of ideas in small groups.",
        "url": "/in_class/day12.html"
      },"how-to-git-setup-html": {
        "title": "Setting up Git for this Course",
        "author": "",
        "category": "",
        "content": "I give you freedom in this course to set up your GitHub repository how you see fit.  I do, however, recommend that you use GitHub (or at least Git as a way to version control your code).One way to organize your work in this class is to make a single top-level repository and then put individual assignment and project repositories below it.  Here is an example of how the sample solutions repository looks (after posting the day 4 solution).├── Class01 (note: this is a project)│   ├── .idea│   │   ├── .gitignore│   │   ├── encodings.xml│   │   ├── kotlinc.xml│   │   ├── misc.xml│   │   └── vcs.xml│   ├── src│   │   ├── main│   │   │   └── kotlin│   │   │       └── Main.kt│   │   └── test│   │       └── kotlin│   │           └── FindPeakTest.kt│   ├── .gitignore│   └── pom.xml├── Class04 (note: this is a project, separate from Class01)│   ├── .idea│   │   ├── .gitignore│   │   ├── encodings.xml│   │   ├── kotlinc.xml│   │   ├── misc.xml│   │   └── vcs.xml│   ├── src│   │   ├── main│   │   │   └── kotlin│   │   │       ├── Main.kt│   │   │       └── Stack.kt│   │   └── test│   │       └── kotlin│   │           └── MyStackTest.kt│   ├── .gitignore│   └── pom.xml├── Class04Optional (note: this is a project, separate from Class04)│   ├── .idea│   │   ├── .gitignore│   │   ├── encodings.xml│   │   ├── kotlinc.xml│   │   ├── misc.xml│   │   └── vcs.xml│   ├── src│   │   └── main│   │       └── kotlin│   │           ├── Main.kt│   │           └── MutableStringList.kt│   ├── .gitignore│   └── pom.xmlSteps to Achieve the Setup Above  Make sure you have git set up properly on your computer (meaning you can run git at a terminal, and it responds with some output)  Make sure you can clone your repos from GitHub with write permissions (e.g., by adding an ssh key to your account and to your machine)  Create a repo on GitHub for your class work.  You can initialize it with a README file.  Clone your repo on your machine with write access (e.g., using ssh).  When you create a new project, select the directory for your cloned repo as the root and give the project a name (this will become a subdirectory inside your repository). Make sure you uncheck the Create Git Repository checkbox (since the git repository is already associated with teh top-level directory)  Use git add, git commit, and git push as normal (these can also be done through the IntelliJ user interface).",
        "url": "/how_to/git_setup.html"
      },"": {
        "title": "Data Structures and Algorithms Spring 2025",
        "author": "",
        "category": "",
        "content": "            How-tos  Get set with Kotlin  Useful Resources (please let me know what I should add to this list).  Git SetupIn-class ActivitiesSample solutions for in-class assignments will be made available on GitHub.            Day #      Activity                  1      Course Intro and Welcome to DSA              2      Greedy Algorithms Teaser, Order of Growth, and Some Kotlin              3      Arrays, Linked Lists, and Intro to Abstract Datatypes              4      Stack Implementation Walkthrough and Challenge Problems              5      Choose Your Own Adventure and Intro to Graphs              6      Graph data structures, depth-first and breadth-first search              7      DAGs, Dijkstra’s Algorithm, and Heaps              8      A-Star Search and Intro to Sorting              9      More Sorting and More Divide and Conquer              10      Divide and Conquer and Intro to Dynamic Programming              11      More Dynamic Programming              12      Dynamic Programming Wrapup and Starting Our Deep Dive      Assignments            Due at beginning of class #      Assignment                  3      Hello Kotlin and Getting to Know You              5      Linked Data Structures              8      Graph Searching and Shortest Paths              10      Sorting Algorithms              12      Divide and Conquer and Dynamic Programming              14      Individual Deep Dive      Oral Quiz Practice Problems  Quiz 1 Practice",
        "url": "/"
      },"assignments-oralquizpractice-01-html": {
        "title": "Oral Quiz Practice",
        "author": "",
        "category": "",
        "content": "Problem 1: Stack CodeHere is an implementation of a stack in Kotlin.  Explain how the code works.  Your response should touch on the role of T, the definition of top (and why it has a nullable type), and how each of the functions works.class MyStack&lt;T&gt;: Stack&lt;T&gt; {    private class StackNode&lt;T&gt;(val data: T,                               var next: StackNode&lt;T&gt;?)    private var top: StackNode&lt;T&gt;? = null    override fun push(data: T) {        top = StackNode&lt;T&gt;(data, top)    }    override fun pop(): T? {        val returnValue = top?.data        top = top?.next        return returnValue    }    override fun peek(): T? {        return top?.data    }    override fun isEmpty(): Boolean {        return top == null    }}Problem 2: Order of GrowthExplain why selection sort (finding the min and putting it at the beginning of the list, finding the second-smallest element and putting it in the second position in the list, etc.) is $\\Theta(n^2)$.Explain the merge sort algorithm and why it has a running time of $\\Theta(n \\log n)$.Problem 3: Binary HeapsOn the whiteboard, explain the concept of a binary heap.  Explain what the heap invariant property is.  Demonstrate how to insert a new element into a binary heap.  Explain why binary heaps are well-suited to implementing priority queues.Problem 4: Broken DijkstraThe pseudocode for Dijkstra’s algorithm is incorrect.  Explain what is wrong with it and how you would fix it.  The code finds the length of the shortest path from source to target.for each vertex, v that is not the source:    dist[v] ← INFINITY    queue.addWithPriority(v, INFINITY)dist[source] ← 0queue.addWithPriority(source, 0)while queue is not empty:    u ← pop min priority element from queue    for each neighbor v of u still in queue:        alt ← dist[u] + edgecost(u, v)        if alt &lt; dist[v]:            dist[v] ← altreturn dist[target]",
        "url": "/assignments/oralquizpractice_01.html"
      },"search-html": {
        "title": "Search Results",
        "author": "",
        "category": "",
        "content": "{% include search-box.html %}",
        "url": "/search.html"
      },"how-to-setting-up-kotlin-html": {
        "title": "Getting Set With Kotlin",
        "author": "",
        "category": "",
        "content": "## Install IntelliJ IDEWe'll be working with the [Kotlin language](https://kotlinlang.org/) (more information and history of the language available [through Wikipedia](https://en.wikipedia.org/wiki/Kotlin_(programming_language)).  The best way to get Kotlin for your computer it install the IntelliJ IDE by JetBrains.  While you can use other IDEs with Kotlin (e.g., VS Code), we strongly recommend you stick IntellIJ (as that is the official IDE for Kotlin).  You can get a free license for Jetbrains since you are part of an academic institution.The [Getting Started page](https://kotlinlang.org/docs/getting-started.html) on the Kotlin website is the place to go to get started on your journey.  As you go through the instructions, make sure to click on the link that says ``IntelliJ IDE``.You should also take advantage of the fact that students can get free access to IntelliJ Ultimate.  This page has some [information on how to get started with accessing these student benefits](https://www.jetbrains.com/academy/student-pack/).## Hello WorldLet's work together to create our first Kotlin Program.  Open up IntellJ, select `File` then `New` then `Project`.Next, make sure you've selected  `Kotlin` as your language  and `Add sample code` should be checked.  Your JDK may look different from what is shown here, that's probably fine (but let me know if you run into issues).  For `Build System`, you can select any of them but Maven seems to work well in my experience).  See below for a screenshot of the new project dialog.![A screenshot of the IntelliJ IDE showing the selection of Kotlin as the programming language](/images/new_project.png)After you click `Create`, a window will open up with your new project.  It should look something like this.![A screenshot of the IntelliJ IDE showing the default project code](/images/configured_project.png).To run this program, click the arrow button near the `Current File` drop down.  You should get output that looks like this.```\"/Applications/IntelliJ IDEA.app/Contents/jbr/Contents/Home/bin/java\" -javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=61644 -Dfile.encoding=UTF-8 -Dsun.stdout.encoding=UTF-8 -Dsun.stderr.encoding=UTF-8 -classpath /Users/pruvolo/Downloads/HelloWorld/out/production/HelloWorld:/Users/pruvolo/.m2/repository/org/jetbrains/kotlin/kotlin-stdlib/2.2.0/kotlin-stdlib-2.2.0.jar:/Users/pruvolo/.m2/repository/org/jetbrains/annotations/13.0/annotations-13.0.jar MainKtHello, Kotlin!i = 1i = 2i = 3i = 4i = 5Process finished with exit code 0```You might be wondering what the red circle is for.  This is a breakpoint that would stop execution of your program if you were to run it under the debugger.  To test this out, click the icon of the bug (right next to the arrow).  IntelliJ will now look like this.![The IntelliJ debugger stopped a breakpoint](/images/debugger.png)Note that the values of the local variables are shown along with the line of code we are executing.  You can continue execution of the program using the ``resume program`` button.  For a more indepth look at the debugger, consult [the IntelliJ documentation on debugging](https://www.jetbrains.com/help/idea/debugging-code.html).## Adding a Dependency on a LibraryThe process for adding a dependency on a third party library (e.g., to add some functionality not present in the Kotlin standard library) will depend on the build system.  Here is an example of how to add a dependency for the `Maven` build system (as selected in the previous section).  This should also work for `Gradle` as well.> Before getting started, configure IntelliJ to automatically download documentation and source for any imported dependencies.  You can do this by going to `Settings` -> `Build, Execution, & Deployment` -> `Build Tools` -> `Maven` -> `Importing` and then checking Automatically download `Sources`, `Documentation`, and `Annotations`.You can approach this in two ways.  First, you can do an ordinary Google search to find your dependency.  For example, if I want to do linear algebra things in Kotlin, I could search `Linear algebra kotlin library'.  From this list, I can usually find some instructions on how to add the library as a dependency.  Alternatively, you can search for the dependency you want to add using the official [Maven Search engine](https://search.maven.org/?eh=) or, if you want a more user-friendly experience, a community-managed [Maven Search Engine Alternative](https://mvnrepository.com/).  If I type in Linear Algebra to the site above, I get the following output.![The search output from mvnrepository.com](/images/maven_search.png)Next, I can pick the library I want by clicking on it and choosing a version.  Let's choose the EJML Simple Library and select the latest version (`0.44`).  There will be a selector to choose the build system you are using.  In our example of using Maven build system we can add the dependency by selecting `Maven` from the tabbed selector, copying the XML fragment (which should look like the following), and pasting it into the `` section of `pom.xml`.```xml    org.ejml    ejml-simple    0.44.0```You will need to click the `Reload` button to complete the process.To work with our dependency, let's modify our code.  If we know a type in the imported module we want to use, we can type it and the editor will automatically suggest the appropriate class to import.  Go ahead and add the following lines to the top of main ```kotlinval q = SimpleMatrix(3, 3)q[0,0] = 3.0print(q)```Initially, the word `SimpleMatrix` will be red since it is not imported.  You can right-click on it and select `Context Actions` and choose `Import SimpleMatrix`.  This will add the appropriate import at the top of your code.What does this code actually do?  Let's access the documentation.  If you click on SimpleMatrix, you should see a pop-up with documentation of what that command does (in this case it creates a matrix with all 0's).  You can further explore the documentation by interacting with the links in the documentation snippet.Some useful keyboard shortcuts for interacting with the documentation and discovering how external libraries work is as follows.* Search Everywhere: Shift Shift * Quick Doc (automatically show documentation in a sidebar): macOS F1 (or Ctrl+J), Win/Linux Ctrl+Q * Go to Declaration / Implementation: ⌘B / ⌥⌘B (Win/Linux Ctrl+B / Ctrl+Alt+B)* Show Usages: ⌥⌘F7 (Win/Linux Alt+F7)* Parameter Info: ⌘P (Win/Linux Ctrl+P)* Navigate Class / Symbol: ⌘O / ⌥⌘O (Win/Linux Ctrl+N / Ctrl+Alt+Shift+N)## A Note about Variation in SetupIf you would like to configure your workflow differently to these steps, that is totally fine.  I leave it to you to make this decision, and I'll do my best to support you should you run into road blocks.",
        "url": "/how_to/setting_up_kotlin.html"
      },"how-to-useful-resources-html": {
        "title": "Useful Resources",
        "author": "",
        "category": "",
        "content": "## Kotlin Resources* [Running code snippets in Kotlin](https://kotlinlang.org/docs/run-code-snippets.html)* [Advent of Code in Idiomatic Kotlin](https://kotlinlang.org/docs/advent-of-code.html) will give you practice in efficiently solving problems with Kotlin.  I haven't watched these (except for the first one of the 2024 series), but they were recommended by a student from last year.  One caveat here is that the examples use idiomatic solutions, which means that they prioritize using language-specific conventions and tricks to solve problems rather than using the most straightforward methods.  While this approach is nice to level-up your Kotlin skills, don't be intimidated that you would have used a different strategy to solve the problems.",
        "url": "/how_to/useful_resources.html"
      },"assets-css-main-css": {
        "title": "",
        "author": "",
        "category": "",
        "content": "@charset \"utf-8\";@import \"minimal-mistakes/skins/{{ site.minimal_mistakes_skin | default: 'default' }}\"; // skin@import \"minimal-mistakes\"; // main partialsimg.mermaid {  max-width: 75%;    height: auto;  }.notice blockquote {  font-style: normal;}.notice--success blockquote {    font-style: normal;}",
        "url": "/assets/css/main.css"
      },"assets-js-lunr-lunr-en-js": {
        "title": "",
        "author": "",
        "category": "",
        "content": "var idx = lunr(function () {  this.field('title')  this.field('excerpt')  this.field('categories')  this.field('tags')  this.ref('id')  this.pipeline.remove(lunr.trimmer)  for (var item in store) {    this.add({      title: store[item].title,      excerpt: store[item].excerpt,      categories: store[item].categories,      tags: store[item].tags,      id: item    })  }});$(document).ready(function() {  $('input#search').on('keyup', function () {    var resultdiv = $('#results');    var query = $(this).val().toLowerCase();    var result =      idx.query(function (q) {        query.split(lunr.tokenizer.separator).forEach(function (term) {          q.term(term, { boost: 100 })          if(query.lastIndexOf(\" \") != query.length-1){            q.term(term, {  usePipeline: false, wildcard: lunr.Query.wildcard.TRAILING, boost: 10 })          }          if (term != \"\"){            q.term(term, {  usePipeline: false, editDistance: 1, boost: 1 })          }        })      });    resultdiv.empty();    resultdiv.prepend(''+result.length+' {{ site.data.ui-text[site.locale].results_found | default: \"Result(s) found\" }}');    for (var item in result) {      var ref = result[item].ref;      if(store[ref].teaser){        var searchitem =          ''+            ''+              ''+                ''+store[ref].title+''+              ''+              ''+                ''+              ''+              ''+store[ref].excerpt.split(\" \").splice(0,20).join(\" \")+'...'+            ''+          '';      }      else{    \t  var searchitem =          ''+            ''+              ''+                ''+store[ref].title+''+              ''+              ''+store[ref].excerpt.split(\" \").splice(0,20).join(\" \")+'...'+            ''+          '';      }      resultdiv.append(searchitem);    }  });});",
        "url": "/assets/js/lunr/lunr-en.js"
      },"assets-js-lunr-lunr-gr-js": {
        "title": "",
        "author": "",
        "category": "",
        "content": "step1list = new Array();step1list[\"ΦΑΓΙΑ\"] = \"ΦΑ\";step1list[\"ΦΑΓΙΟΥ\"] = \"ΦΑ\";step1list[\"ΦΑΓΙΩΝ\"] = \"ΦΑ\";step1list[\"ΣΚΑΓΙΑ\"] = \"ΣΚΑ\";step1list[\"ΣΚΑΓΙΟΥ\"] = \"ΣΚΑ\";step1list[\"ΣΚΑΓΙΩΝ\"] = \"ΣΚΑ\";step1list[\"ΟΛΟΓΙΟΥ\"] = \"ΟΛΟ\";step1list[\"ΟΛΟΓΙΑ\"] = \"ΟΛΟ\";step1list[\"ΟΛΟΓΙΩΝ\"] = \"ΟΛΟ\";step1list[\"ΣΟΓΙΟΥ\"] = \"ΣΟ\";step1list[\"ΣΟΓΙΑ\"] = \"ΣΟ\";step1list[\"ΣΟΓΙΩΝ\"] = \"ΣΟ\";step1list[\"ΤΑΤΟΓΙΑ\"] = \"ΤΑΤΟ\";step1list[\"ΤΑΤΟΓΙΟΥ\"] = \"ΤΑΤΟ\";step1list[\"ΤΑΤΟΓΙΩΝ\"] = \"ΤΑΤΟ\";step1list[\"ΚΡΕΑΣ\"] = \"ΚΡΕ\";step1list[\"ΚΡΕΑΤΟΣ\"] = \"ΚΡΕ\";step1list[\"ΚΡΕΑΤΑ\"] = \"ΚΡΕ\";step1list[\"ΚΡΕΑΤΩΝ\"] = \"ΚΡΕ\";step1list[\"ΠΕΡΑΣ\"] = \"ΠΕΡ\";step1list[\"ΠΕΡΑΤΟΣ\"] = \"ΠΕΡ\";step1list[\"ΠΕΡΑΤΑ\"] = \"ΠΕΡ\";step1list[\"ΠΕΡΑΤΩΝ\"] = \"ΠΕΡ\";step1list[\"ΤΕΡΑΣ\"] = \"ΤΕΡ\";step1list[\"ΤΕΡΑΤΟΣ\"] = \"ΤΕΡ\";step1list[\"ΤΕΡΑΤΑ\"] = \"ΤΕΡ\";step1list[\"ΤΕΡΑΤΩΝ\"] = \"ΤΕΡ\";step1list[\"ΦΩΣ\"] = \"ΦΩ\";step1list[\"ΦΩΤΟΣ\"] = \"ΦΩ\";step1list[\"ΦΩΤΑ\"] = \"ΦΩ\";step1list[\"ΦΩΤΩΝ\"] = \"ΦΩ\";step1list[\"ΚΑΘΕΣΤΩΣ\"] = \"ΚΑΘΕΣΤ\";step1list[\"ΚΑΘΕΣΤΩΤΟΣ\"] = \"ΚΑΘΕΣΤ\";step1list[\"ΚΑΘΕΣΤΩΤΑ\"] = \"ΚΑΘΕΣΤ\";step1list[\"ΚΑΘΕΣΤΩΤΩΝ\"] = \"ΚΑΘΕΣΤ\";step1list[\"ΓΕΓΟΝΟΣ\"] = \"ΓΕΓΟΝ\";step1list[\"ΓΕΓΟΝΟΤΟΣ\"] = \"ΓΕΓΟΝ\";step1list[\"ΓΕΓΟΝΟΤΑ\"] = \"ΓΕΓΟΝ\";step1list[\"ΓΕΓΟΝΟΤΩΝ\"] = \"ΓΕΓΟΝ\";v = \"[ΑΕΗΙΟΥΩ]\";v2 = \"[ΑΕΗΙΟΩ]\"function stemWord(w) {  var stem;  var suffix;  var firstch;  var origword = w;  test1 = new Boolean(true);  if(w.length '+result.length+' {{ site.data.ui-text[site.locale].results_found | default: \"Result(s) found\" }}');    for (var item in result) {      var ref = result[item].ref;      if(store[ref].teaser){        var searchitem =          ''+            ''+              ''+                ''+store[ref].title+''+              ''+              ''+                ''+              ''+              ''+store[ref].excerpt.split(\" \").splice(0,20).join(\" \")+'...'+            ''+          '';      }      else{    \t  var searchitem =          ''+            ''+              ''+                ''+store[ref].title+''+              ''+              ''+store[ref].excerpt.split(\" \").splice(0,20).join(\" \")+'...'+            ''+          '';      }      resultdiv.append(searchitem);    }  });});",
        "url": "/assets/js/lunr/lunr-gr.js"
      },"assets-js-lunr-lunr-store-js": {
        "title": "",
        "author": "",
        "category": "",
        "content": "var store = [  {%- for c in site.collections -%}    {%- if forloop.last -%}      {%- assign l = true -%}    {%- endif -%}    {%- assign docs = c.docs | where_exp:'doc','doc.search != false' -%}    {%- for doc in docs -%}      {%- if doc.header.teaser -%}        {%- capture teaser -%}{{ doc.header.teaser }}{%- endcapture -%}      {%- else -%}        {%- assign teaser = site.teaser -%}      {%- endif -%}      {        \"title\": {{ doc.title | jsonify }},        \"excerpt\":          {%- if site.search_full_content == true -%}            {{ doc.content | newline_to_br |              replace:\"\", \" \" |              replace:\"\", \" \" |              replace:\"\", \" \" |              replace:\"\", \" \" |              replace:\"\", \" \" |              replace:\"\", \" \" |              replace:\"\", \" \" |              replace:\"\", \" \"|            strip_html | strip_newlines | jsonify }},          {%- else -%}            {{ doc.content | newline_to_br |              replace:\"\", \" \" |              replace:\"\", \" \" |              replace:\"\", \" \" |              replace:\"\", \" \" |              replace:\"\", \" \" |              replace:\"\", \" \" |              replace:\"\", \" \" |              replace:\"\", \" \"|            strip_html | strip_newlines | truncatewords: 50 | jsonify }},          {%- endif -%}        \"categories\": {{ doc.categories | jsonify }},        \"tags\": {{ doc.tags | jsonify }},        \"url\": {{ doc.url | absolute_url | jsonify }},        \"teaser\":          {%- if teaser contains \"://\" -%}            {{ teaser | jsonify }}          {%- else -%}            {{ teaser | absolute_url | jsonify }}          {%- endif -%}      }{%- unless forloop.last and l -%},{%- endunless -%}    {%- endfor -%}  {%- endfor -%}]",
        "url": "/assets/js/lunr/lunr-store.js"
      },"feed-xml": {
        "title": "",
        "author": "",
        "category": "",
        "content": "{% if page.xsl %}{% endif %}Jekyll{{ site.time | date_to_xmlschema }}{{ page.url | absolute_url | xml_escape }}{% assign title = site.title | default: site.name %}{% if page.collection != \"posts\" %}{% assign collection = page.collection | capitalize %}{% assign title = title | append: \" | \" | append: collection %}{% endif %}{% if page.category %}{% assign category = page.category | capitalize %}{% assign title = title | append: \" | \" | append: category %}{% endif %}{% if title %}{{ title | smartify | xml_escape }}{% endif %}{% if site.description %}{{ site.description | xml_escape }}{% endif %}{% if site.author %}{{ site.author.name | default: site.author | xml_escape }}{% if site.author.email %}{{ site.author.email | xml_escape }}{% endif %}{% if site.author.uri %}{{ site.author.uri | xml_escape }}{% endif %}{% endif %}{% if page.tags %}{% assign posts = site.tags[page.tags] %}{% else %}{% assign posts = site[page.collection] %}{% endif %}{% if page.category %}{% assign posts = posts | where: \"categories\", page.category %}{% endif %}{% unless site.show_drafts %}{% assign posts = posts | where_exp: \"post\", \"post.draft != true\" %}{% endunless %}{% assign posts = posts | sort: \"date\" | reverse %}{% assign posts_limit = site.feed.posts_limit | default: 10 %}{% for post in posts limit: posts_limit %}{% assign post_title = post.title | smartify | strip_html | normalize_whitespace | xml_escape %}{{ post_title }}{{ post.date | date_to_xmlschema }}{{ post.last_modified_at | default: post.date | date_to_xmlschema }}{{ post.id | absolute_url | xml_escape }}{% assign excerpt_only = post.feed.excerpt_only | default: site.feed.excerpt_only %}{% unless excerpt_only %}{% endunless %}{% assign post_author = post.author | default: post.authors[0] | default: site.author %}{% assign post_author = site.data.authors[post_author] | default: post_author %}{% assign post_author_email = post_author.email | default: nil %}{% assign post_author_uri = post_author.uri | default: nil %}{% assign post_author_name = post_author.name | default: post_author %}{{ post_author_name | default: \"\" | xml_escape }}{% if post_author_email %}{{ post_author_email | xml_escape }}{% endif %}{% if post_author_uri %}{{ post_author_uri | xml_escape }}{% endif %}{% if post.category %}{% elsif post.categories %}{% for category in post.categories %}{% endfor %}{% endif %}{% for tag in post.tags %}{% endfor %}{% assign post_summary = post.description | default: post.excerpt %}{% if post_summary and post_summary != empty %}{% endif %}{% assign post_image = post.image.path | default: post.image %}{% if post_image %}{% unless post_image contains \"://\" %}{% assign post_image = post_image | absolute_url %}{% endunless %}{% endif %}{% endfor %}",
        "url": "/feed.xml"
      },"sitemap-xml": {
        "title": "",
        "author": "",
        "category": "",
        "content": "{% if page.xsl %}{% endif %}{% assign collections = site.collections | where_exp:'collection','collection.output != false' %}{% for collection in collections %}{% assign docs = collection.docs | where_exp:'doc','doc.sitemap != false' %}{% for doc in docs %}{{ doc.url | replace:'/index.html','/' | absolute_url | xml_escape }}{% if doc.last_modified_at or doc.date %}{{ doc.last_modified_at | default: doc.date | date_to_xmlschema }}{% endif %}{% endfor %}{% endfor %}{% assign pages = site.html_pages | where_exp:'doc','doc.sitemap != false' | where_exp:'doc','doc.url != \"/404.html\"' %}{% for page in pages %}{{ page.url | replace:'/index.html','/' | absolute_url | xml_escape }}{% if page.last_modified_at %}{{ page.last_modified_at | date_to_xmlschema }}{% endif %}{% endfor %}{% assign static_files = page.static_files | where_exp:'page','page.sitemap != false' | where_exp:'page','page.name != \"404.html\"' %}{% for file in static_files %}{{ file.path | replace:'/index.html','/' | absolute_url | xml_escape }}{{ file.modified_time | date_to_xmlschema }}{% endfor %}",
        "url": "/sitemap.xml"
      },"robots-txt": {
        "title": "",
        "author": "",
        "category": "",
        "content": "Sitemap: {{ \"sitemap.xml\" | absolute_url }}",
        "url": "/robots.txt"
      }};
</script>

<!-- Import lunr.js from unpkg.com -->
<script src="https://unpkg.com/lunr/lunr.js"></script>

<!-- Custom search script which we will create below -->
<script src="/js/search.js"></script>


        
      </section>

      <footer class="page__meta">
        
        


        
      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 Data Structures Fall 2025 @ Olin College.</div>

      </footer>
    </div>

    <script src="/assets/js/copyCode.js"></script>


  <script src="/assets/js/main.min.js"></script>
  <script src="https://kit.fontawesome.com/4eee35f757.js"></script>










  </body>
</html>
